function extractProps(props, propDefs) {
  let className = (props.className || "").split(" ");
  let style = { ...props.style };
  const hasProp = (key) => props.hasOwnProperty(key);
  for (const key in propDefs) {
    if (!hasProp(key) && !propDefs[key].hasOwnProperty("default")) {
      continue;
    }
    const value = hasProp(key) ? props[key] : propDefs[key].default;
    const propDefsValues = propDefs[key].values;
    const propDefsCustomProperties = propDefs[key].customProperties;
    const propDefsClassName = propDefs[key].className;
    const isResponsive = propDefs[key].responsive;
    const handleValue = (val, prefix = "") => {
      if (key === "as") return;
      if (propDefsValues.includes(val)) {
        className.push(`${prefix}${propDefsClassName}-${val}`);
      } else {
        const customPropertyKey = isResponsive && prefix ? `${propDefsCustomProperties}-${prefix.slice(0, -1)}` : propDefsCustomProperties;
        style[customPropertyKey] = val;
        className.push(`${prefix}${propDefsClassName}`);
      }
    };
    if (isResponsive && typeof value === "object") {
      for (const breakpoint in value) {
        const prefix = breakpoint === "initial" ? "" : `${breakpoint}:`;
        handleValue(value[breakpoint], prefix);
      }
    } else {
      handleValue(value);
    }
  }
  const cleanedProps = Object.keys(props).reduce((acc, key) => {
    if (!propDefs.hasOwnProperty(key)) {
      acc[key] = props[key];
    }
    return acc;
  }, {});
  const newClassNames = className.filter((name) => name && name.trim() !== "").join(" ");
  return { ...cleanedProps, className: newClassNames, style };
}

export { extractProps };
//# sourceMappingURL=extractProps.esm.js.map
