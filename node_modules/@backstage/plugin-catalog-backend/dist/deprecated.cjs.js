'use strict';

var backendCommon = require('@backstage/backend-common');
var catalogClient = require('@backstage/catalog-client');
var catalogModel = require('@backstage/catalog-model');
var alpha = require('@backstage/plugin-catalog-common/alpha');
var pluginCatalogNode = require('@backstage/plugin-catalog-node');
var pluginSearchBackendModuleCatalog = require('@backstage/plugin-search-backend-module-catalog');
var stream = require('stream');

const locationSpecToMetadataName = pluginCatalogNode.locationSpecToMetadataName;
const locationSpecToLocationEntity = pluginCatalogNode.locationSpecToLocationEntity;
const processingResult = pluginCatalogNode.processingResult;
var search;
((search2) => {
  const configKey = "search.collators.catalog";
  const defaults = {
    schedule: {
      frequency: { minutes: 10 },
      timeout: { minutes: 15 },
      initialDelay: { seconds: 3 }
    },
    collatorOptions: {
      locationTemplate: "/catalog/:namespace/:kind/:name",
      filter: void 0,
      batchSize: 500
    }
  };
  search2.readCollatorConfigOptions = (configRoot) => {
    const config = configRoot.getOptionalConfig(configKey);
    if (!config) {
      return defaults.collatorOptions;
    }
    return {
      locationTemplate: config.getOptionalString("locationTemplate") ?? defaults.collatorOptions.locationTemplate,
      filter: config.getOptional("filter") ?? defaults.collatorOptions.filter,
      batchSize: config.getOptionalNumber("batchSize") ?? defaults.collatorOptions.batchSize
    };
  };
  search2.getDocumentText = (entity) => {
    const documentTexts = [];
    if (entity.metadata.description) {
      documentTexts.push(entity.metadata.description);
    }
    if (catalogModel.isUserEntity(entity) || catalogModel.isGroupEntity(entity)) {
      if (entity.spec?.profile?.displayName) {
        documentTexts.push(entity.spec.profile.displayName);
      }
    }
    if (catalogModel.isUserEntity(entity)) {
      if (entity.spec?.profile?.email) {
        documentTexts.push(entity.spec.profile.email);
      }
    }
    return documentTexts.join(" : ");
  };
})(search || (search = {}));
const defaultCatalogCollatorEntityTransformer = pluginSearchBackendModuleCatalog.defaultCatalogCollatorEntityTransformer;
class DefaultCatalogCollatorFactory {
  type = "software-catalog";
  visibilityPermission = alpha.catalogEntityReadPermission;
  locationTemplate;
  filter;
  batchSize;
  catalogClient;
  entityTransformer;
  auth;
  static fromConfig(configRoot, options) {
    const configOptions = search.readCollatorConfigOptions(configRoot);
    const { auth: adaptedAuth } = backendCommon.createLegacyAuthAdapters({
      auth: options.auth,
      discovery: options.discovery,
      tokenManager: options.tokenManager
    });
    return new DefaultCatalogCollatorFactory({
      locationTemplate: options.locationTemplate ?? configOptions.locationTemplate,
      filter: options.filter ?? configOptions.filter,
      batchSize: options.batchSize ?? configOptions.batchSize,
      entityTransformer: options.entityTransformer,
      auth: adaptedAuth,
      discovery: options.discovery,
      catalogClient: options.catalogClient
    });
  }
  constructor(options) {
    const {
      auth,
      batchSize,
      discovery,
      locationTemplate,
      filter,
      catalogClient: catalogClient$1,
      entityTransformer
    } = options;
    this.locationTemplate = locationTemplate;
    this.filter = filter;
    this.batchSize = batchSize;
    this.catalogClient = catalogClient$1 || new catalogClient.CatalogClient({ discoveryApi: discovery });
    this.entityTransformer = entityTransformer ?? defaultCatalogCollatorEntityTransformer;
    this.auth = auth;
  }
  async getCollator() {
    return stream.Readable.from(this.execute());
  }
  async *execute() {
    let entitiesRetrieved = 0;
    let cursor = void 0;
    do {
      const { token } = await this.auth.getPluginRequestToken({
        onBehalfOf: await this.auth.getOwnServiceCredentials(),
        targetPluginId: "catalog"
      });
      const response = await this.catalogClient.queryEntities(
        {
          filter: this.filter,
          limit: this.batchSize,
          ...cursor ? { cursor } : {}
        },
        { token }
      );
      cursor = response.pageInfo.nextCursor;
      entitiesRetrieved += response.items.length;
      for (const entity of response.items) {
        yield {
          ...this.entityTransformer(entity),
          authorization: {
            resourceRef: catalogModel.stringifyEntityRef(entity)
          },
          location: this.applyArgsToFormat(this.locationTemplate, {
            namespace: entity.metadata.namespace || "default",
            kind: entity.kind,
            name: entity.metadata.name
          })
        };
      }
    } while (cursor);
  }
  applyArgsToFormat(format, args) {
    let formatted = format;
    for (const [key, value] of Object.entries(args)) {
      formatted = formatted.replace(`:${key}`, value);
    }
    return formatted.toLowerCase();
  }
}

exports.DefaultCatalogCollatorFactory = DefaultCatalogCollatorFactory;
exports.defaultCatalogCollatorEntityTransformer = defaultCatalogCollatorEntityTransformer;
exports.locationSpecToLocationEntity = locationSpecToLocationEntity;
exports.locationSpecToMetadataName = locationSpecToMetadataName;
exports.processingResult = processingResult;
//# sourceMappingURL=deprecated.cjs.js.map
