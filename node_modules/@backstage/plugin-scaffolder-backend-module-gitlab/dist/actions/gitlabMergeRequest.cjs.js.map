{"version":3,"file":"gitlabMergeRequest.cjs.js","sources":["../../src/actions/gitlabMergeRequest.ts"],"sourcesContent":["/*\n * Copyright 2021 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  createTemplateAction,\n  parseRepoUrl,\n  SerializedFile,\n  serializeDirectoryContents,\n} from '@backstage/plugin-scaffolder-node';\nimport {\n  Camelize,\n  CommitAction,\n  ExpandedMergeRequestSchema,\n  Gitlab,\n  RepositoryTreeSchema,\n  SimpleUserSchema,\n} from '@gitbeaker/rest';\nimport path from 'path';\nimport { ScmIntegrationRegistry } from '@backstage/integration';\nimport { InputError } from '@backstage/errors';\nimport {\n  LoggerService,\n  resolveSafeChildPath,\n} from '@backstage/backend-plugin-api';\nimport { createGitlabApi, getErrorMessage } from './helpers';\nimport { examples } from './gitlabMergeRequest.examples';\nimport { createHash } from 'crypto';\n\nfunction computeSha256(file: SerializedFile): string {\n  const hash = createHash('sha256');\n  hash.update(file.content);\n  return hash.digest('hex');\n}\n\nasync function getFileAction(\n  fileInfo: { file: SerializedFile; targetPath?: string },\n  target: { repoID: string; branch: string },\n  api: InstanceType<typeof Gitlab>,\n  logger: LoggerService,\n  remoteFiles: RepositoryTreeSchema[],\n  defaultCommitAction:\n    | 'create'\n    | 'delete'\n    | 'update'\n    | 'skip'\n    | 'auto' = 'auto',\n): Promise<'create' | 'delete' | 'update' | 'skip'> {\n  if (defaultCommitAction === 'auto') {\n    const filePath = path.join(fileInfo.targetPath ?? '', fileInfo.file.path);\n\n    if (remoteFiles?.some(remoteFile => remoteFile.path === filePath)) {\n      try {\n        const targetFile = await api.RepositoryFiles.show(\n          target.repoID,\n          filePath,\n          target.branch,\n        );\n        if (computeSha256(fileInfo.file) === targetFile.content_sha256) {\n          return 'skip';\n        }\n      } catch (error) {\n        logger.warn(\n          `Unable to retrieve detailed information for remote file ${filePath}`,\n        );\n      }\n      return 'update';\n    }\n    return 'create';\n  }\n  return defaultCommitAction;\n}\n\nasync function getReviewersFromApprovalRules(\n  api: InstanceType<typeof Gitlab>,\n  mergerequestIId: number,\n  repoID: string,\n  ctx: any,\n): Promise<number[]> {\n  try {\n    // Because we don't know the code owners before the MR is created, we can't check the approval rules beforehand.\n    // Getting the approval rules beforehand is very difficult, especially, because of the inheritance rules for groups.\n    // Code owners take a moment to be processed and added to the approval rules after the MR is created.\n\n    let mergeRequest:\n      | ExpandedMergeRequestSchema\n      | Camelize<ExpandedMergeRequestSchema> = await api.MergeRequests.show(\n      repoID,\n      mergerequestIId,\n    );\n\n    while (\n      mergeRequest.detailed_merge_status === 'preparing' ||\n      mergeRequest.detailed_merge_status === 'approvals_syncing' ||\n      mergeRequest.detailed_merge_status === 'checking'\n    ) {\n      mergeRequest = await api.MergeRequests.show(repoID, mergeRequest.iid);\n      ctx.logger.info(`${mergeRequest.detailed_merge_status}`);\n    }\n\n    const approvalRules = await api.MergeRequestApprovals.allApprovalRules(\n      repoID,\n      {\n        mergerequestIId: mergeRequest.iid,\n      },\n    );\n\n    return approvalRules\n      .filter(rule => rule.eligible_approvers !== undefined)\n      .map(rule => {\n        return rule.eligible_approvers as SimpleUserSchema[];\n      })\n      .flat()\n      .map(user => user.id);\n  } catch (e) {\n    ctx.logger.warn(\n      `Failed to retrieve approval rules for MR ${mergerequestIId}: ${getErrorMessage(\n        e,\n      )}. Proceeding with MR creation without reviewers from approval rules.`,\n    );\n    return [];\n  }\n}\n\n/**\n * Create a new action that creates a gitlab merge request.\n *\n * @public\n */\nexport const createPublishGitlabMergeRequestAction = (options: {\n  integrations: ScmIntegrationRegistry;\n}) => {\n  const { integrations } = options;\n\n  return createTemplateAction<{\n    repoUrl: string;\n    title: string;\n    description: string;\n    branchName: string;\n    targetBranchName?: string;\n    sourcePath?: string;\n    targetPath?: string;\n    token?: string;\n    commitAction?: 'create' | 'delete' | 'update' | 'skip' | 'auto';\n    /** @deprecated projectID passed as query parameters in the repoUrl */\n    projectid?: string;\n    removeSourceBranch?: boolean;\n    assignee?: string;\n    reviewers?: string[];\n    assignReviewersFromApprovalRules?: boolean;\n  }>({\n    id: 'publish:gitlab:merge-request',\n    examples,\n    schema: {\n      input: {\n        required: ['repoUrl', 'branchName'],\n        type: 'object',\n        properties: {\n          repoUrl: {\n            type: 'string',\n            title: 'Repository Location',\n            description: `\\\nAccepts the format 'gitlab.com?repo=project_name&owner=group_name' where \\\n'project_name' is the repository name and 'group_name' is a group or username`,\n          },\n          /** @deprecated projectID is passed as query parameters in the repoUrl */\n          projectid: {\n            type: 'string',\n            title: 'projectid',\n            description: 'Project ID/Name(slug) of the Gitlab Project',\n          },\n          title: {\n            type: 'string',\n            title: 'Merge Request Name',\n            description: 'The name for the merge request',\n          },\n          description: {\n            type: 'string',\n            title: 'Merge Request Description',\n            description: 'The description of the merge request',\n          },\n          branchName: {\n            type: 'string',\n            title: 'Source Branch Name',\n            description: 'The source branch name of the merge request',\n          },\n          targetBranchName: {\n            type: 'string',\n            title: 'Target Branch Name',\n            description: 'The target branch name of the merge request',\n          },\n          sourcePath: {\n            type: 'string',\n            title: 'Working Subdirectory',\n            description: `\\\nSubdirectory of working directory to copy changes from. \\\nFor reasons of backward compatibility, any specified 'targetPath' input will \\\nbe applied in place of an absent/falsy value for this input. \\\nCircumvent this behavior using '.'`,\n          },\n          targetPath: {\n            type: 'string',\n            title: 'Repository Subdirectory',\n            description: 'Subdirectory of repository to apply changes to',\n          },\n          token: {\n            title: 'Authentication Token',\n            type: 'string',\n            description: 'The token to use for authorization to GitLab',\n          },\n          commitAction: {\n            title: 'Commit action',\n            type: 'string',\n            enum: ['create', 'update', 'delete', 'auto'],\n            description: `\\\nThe action to be used for git commit. Defaults to the custom 'auto' action provided by backstage,\nwhich uses additional API calls in order to detect whether to 'create', 'update' or 'skip' each source file.`,\n          },\n          removeSourceBranch: {\n            title: 'Delete source branch',\n            type: 'boolean',\n            description:\n              'Option to delete source branch once the MR has been merged. Default: false',\n          },\n          assignee: {\n            title: 'Merge Request Assignee',\n            type: 'string',\n            description: 'User this merge request will be assigned to',\n          },\n          reviewers: {\n            title: 'Merge Request Reviewers',\n            type: 'array',\n            items: {\n              type: 'string',\n            },\n            description: 'Users that will be assigned as reviewers',\n          },\n          assignReviewersFromApprovalRules: {\n            title: 'Assign reviewers from approval rules',\n            type: 'boolean',\n            description:\n              'Automatically assign reviewers from the approval rules of the MR. Includes Codeowners',\n          },\n        },\n      },\n      output: {\n        type: 'object',\n        properties: {\n          targetBranchName: {\n            title: 'Target branch name of the merge request',\n            type: 'string',\n          },\n          projectid: {\n            title: 'Gitlab Project id/Name(slug)',\n            type: 'string',\n          },\n          projectPath: {\n            title: 'Gitlab Project path',\n            type: 'string',\n          },\n          mergeRequestUrl: {\n            title: 'MergeRequest(MR) URL',\n            type: 'string',\n            description: 'Link to the merge request in GitLab',\n          },\n        },\n      },\n    },\n    async handler(ctx) {\n      const {\n        assignee,\n        reviewers,\n        branchName,\n        targetBranchName,\n        description,\n        repoUrl,\n        removeSourceBranch,\n        targetPath,\n        sourcePath,\n        title,\n        token,\n      } = ctx.input;\n\n      const { owner, repo, project } = parseRepoUrl(repoUrl, integrations);\n      const repoID = project ? project : `${owner}/${repo}`;\n\n      const api = createGitlabApi({\n        integrations,\n        token,\n        repoUrl,\n      });\n\n      let assigneeId: number | undefined = undefined;\n\n      if (assignee !== undefined) {\n        try {\n          const assigneeUser = await api.Users.all({ username: assignee });\n          assigneeId = assigneeUser[0].id;\n        } catch (e) {\n          ctx.logger.warn(\n            `Failed to find gitlab user id for ${assignee}: ${getErrorMessage(\n              e,\n            )}. Proceeding with MR creation without an assignee.`,\n          );\n        }\n      }\n\n      let reviewerIds: number[] | undefined = undefined; // Explicitly set to undefined. Strangely, passing an empty array to the API will result the other options being undefined also being explicity passed to the Gitlab API call (e.g. assigneeId)\n      if (reviewers !== undefined) {\n        reviewerIds = (\n          await Promise.all(\n            reviewers.map(async reviewer => {\n              try {\n                const reviewerUser = await api.Users.all({\n                  username: reviewer,\n                });\n                return reviewerUser[0].id;\n              } catch (e) {\n                ctx.logger.warn(\n                  `Failed to find gitlab user id for ${reviewer}: ${e}. Proceeding with MR creation without reviewer.`,\n                );\n                return undefined;\n              }\n            }),\n          )\n        ).filter(id => id !== undefined) as number[];\n      }\n\n      let fileRoot: string;\n      if (sourcePath) {\n        fileRoot = resolveSafeChildPath(ctx.workspacePath, sourcePath);\n      } else if (targetPath) {\n        // for backward compatibility\n        fileRoot = resolveSafeChildPath(ctx.workspacePath, targetPath);\n      } else {\n        fileRoot = ctx.workspacePath;\n      }\n\n      const fileContents = await serializeDirectoryContents(fileRoot, {\n        gitignore: true,\n      });\n\n      let targetBranch = targetBranchName;\n      if (!targetBranch) {\n        const projects = await api.Projects.show(repoID);\n        const defaultBranch = projects.default_branch ?? projects.defaultBranch;\n        if (typeof defaultBranch !== 'string' || !defaultBranch) {\n          throw new InputError(\n            `The branch creation failed. Target branch was not provided, and could not find default branch from project settings. Project: ${JSON.stringify(\n              project,\n            )}`,\n          );\n        }\n        targetBranch = defaultBranch;\n      }\n\n      let remoteFiles: RepositoryTreeSchema[] = [];\n      if ((ctx.input.commitAction ?? 'auto') === 'auto') {\n        try {\n          remoteFiles = await api.Repositories.allRepositoryTrees(repoID, {\n            ref: targetBranch,\n            recursive: true,\n            path: targetPath ?? undefined,\n          });\n        } catch (e) {\n          ctx.logger.warn(\n            `Could not retrieve the list of files for ${repoID} (branch: ${targetBranch}) : ${getErrorMessage(\n              e,\n            )}`,\n          );\n        }\n      }\n      const actions: CommitAction[] =\n        ctx.input.commitAction === 'skip'\n          ? []\n          : (\n              (\n                await Promise.all(\n                  fileContents.map(async file => {\n                    const action = await getFileAction(\n                      { file, targetPath },\n                      { repoID, branch: targetBranch! },\n                      api,\n                      ctx.logger,\n                      remoteFiles,\n                      ctx.input.commitAction,\n                    );\n                    return { file, action };\n                  }),\n                )\n              ).filter(o => o.action !== 'skip') as {\n                file: SerializedFile;\n                action: CommitAction['action'];\n              }[]\n            ).map(({ file, action }) => ({\n              action,\n              filePath: targetPath\n                ? path.posix.join(targetPath, file.path)\n                : file.path,\n              encoding: 'base64',\n              content: file.content.toString('base64'),\n              execute_filemode: file.executable,\n            }));\n\n      let createBranch: boolean;\n      if (actions.length) {\n        createBranch = true;\n      } else {\n        try {\n          await api.Branches.show(repoID, branchName);\n          createBranch = false;\n          ctx.logger.info(\n            `Using existing branch ${branchName} without modification.`,\n          );\n        } catch (e) {\n          createBranch = true;\n        }\n      }\n      if (createBranch) {\n        try {\n          await api.Branches.create(repoID, branchName, String(targetBranch));\n        } catch (e) {\n          throw new InputError(\n            `The branch creation failed. Please check that your repo does not already contain a branch named '${branchName}'. ${getErrorMessage(\n              e,\n            )}`,\n          );\n        }\n      }\n      await ctx.checkpoint({\n        key: `commit.to.${repoID}.${branchName}`,\n        fn: async () => {\n          if (actions.length) {\n            try {\n              const commit = await api.Commits.create(\n                repoID,\n                branchName,\n                title,\n                actions,\n              );\n              return commit.id;\n            } catch (e) {\n              throw new InputError(\n                `Committing the changes to ${branchName} failed. Please check that none of the files created by the template already exists. ${getErrorMessage(\n                  e,\n                )}`,\n              );\n            }\n          }\n          return null;\n        },\n      });\n\n      const { mrId, mrWebUrl } = await ctx.checkpoint({\n        key: `create.mr.${repoID}.${branchName}`,\n        fn: async () => {\n          try {\n            const mergeRequest = await api.MergeRequests.create(\n              repoID,\n              branchName,\n              String(targetBranch),\n              title,\n              {\n                description,\n                removeSourceBranch: removeSourceBranch\n                  ? removeSourceBranch\n                  : false,\n                assigneeId,\n                reviewerIds,\n              },\n            );\n            return {\n              mrId: mergeRequest.iid,\n              mrWebUrl: mergeRequest.web_url ?? mergeRequest.webUrl,\n            };\n          } catch (e) {\n            throw new InputError(\n              `Merge request creation failed. ${getErrorMessage(e)}`,\n            );\n          }\n        },\n      });\n\n      await ctx.checkpoint({\n        key: `create.mr.assign.reviewers.${repoID}.${branchName}`,\n        fn: async () => {\n          if (ctx.input.assignReviewersFromApprovalRules) {\n            try {\n              const reviewersFromApprovalRules =\n                await getReviewersFromApprovalRules(api, mrId, repoID, ctx);\n              if (reviewersFromApprovalRules.length > 0) {\n                const eligibleUserIds = new Set([\n                  ...reviewersFromApprovalRules,\n                  ...(reviewerIds ?? []),\n                ]);\n\n                const mergeRequest = await api.MergeRequests.edit(\n                  repoID,\n                  mrId,\n                  {\n                    reviewerIds: Array.from(eligibleUserIds),\n                  },\n                );\n                return {\n                  mrWebUrl: mergeRequest.web_url ?? mergeRequest.webUrl,\n                };\n              }\n            } catch (e) {\n              ctx.logger.warn(\n                `Failed to assign reviewers from approval rules: ${getErrorMessage(\n                  e,\n                )}.`,\n              );\n            }\n          }\n          return { mrWebUrl };\n        },\n      });\n\n      ctx.output('projectid', repoID);\n      ctx.output('targetBranchName', targetBranch);\n      ctx.output('projectPath', repoID);\n      ctx.output('mergeRequestUrl', mrWebUrl);\n    },\n  });\n};\n"],"names":["createHash","path","getErrorMessage","createTemplateAction","examples","parseRepoUrl","createGitlabApi","resolveSafeChildPath","serializeDirectoryContents","InputError"],"mappings":";;;;;;;;;;;;;;AAyCA,SAAS,cAAc,IAA8B,EAAA;AACnD,EAAM,MAAA,IAAA,GAAOA,kBAAW,QAAQ,CAAA;AAChC,EAAK,IAAA,CAAA,MAAA,CAAO,KAAK,OAAO,CAAA;AACxB,EAAO,OAAA,IAAA,CAAK,OAAO,KAAK,CAAA;AAC1B;AAEA,eAAe,cACb,QACA,EAAA,MAAA,EACA,KACA,MACA,EAAA,WAAA,EACA,sBAKa,MACqC,EAAA;AAClD,EAAA,IAAI,wBAAwB,MAAQ,EAAA;AAClC,IAAM,MAAA,QAAA,GAAWC,sBAAK,IAAK,CAAA,QAAA,CAAS,cAAc,EAAI,EAAA,QAAA,CAAS,KAAK,IAAI,CAAA;AAExE,IAAA,IAAI,aAAa,IAAK,CAAA,CAAA,UAAA,KAAc,UAAW,CAAA,IAAA,KAAS,QAAQ,CAAG,EAAA;AACjE,MAAI,IAAA;AACF,QAAM,MAAA,UAAA,GAAa,MAAM,GAAA,CAAI,eAAgB,CAAA,IAAA;AAAA,UAC3C,MAAO,CAAA,MAAA;AAAA,UACP,QAAA;AAAA,UACA,MAAO,CAAA;AAAA,SACT;AACA,QAAA,IAAI,aAAc,CAAA,QAAA,CAAS,IAAI,CAAA,KAAM,WAAW,cAAgB,EAAA;AAC9D,UAAO,OAAA,MAAA;AAAA;AACT,eACO,KAAO,EAAA;AACd,QAAO,MAAA,CAAA,IAAA;AAAA,UACL,2DAA2D,QAAQ,CAAA;AAAA,SACrE;AAAA;AAEF,MAAO,OAAA,QAAA;AAAA;AAET,IAAO,OAAA,QAAA;AAAA;AAET,EAAO,OAAA,mBAAA;AACT;AAEA,eAAe,6BACb,CAAA,GAAA,EACA,eACA,EAAA,MAAA,EACA,GACmB,EAAA;AACnB,EAAI,IAAA;AAKF,IAAI,IAAA,YAAA,GAEuC,MAAM,GAAA,CAAI,aAAc,CAAA,IAAA;AAAA,MACjE,MAAA;AAAA,MACA;AAAA,KACF;AAEA,IACE,OAAA,YAAA,CAAa,0BAA0B,WACvC,IAAA,YAAA,CAAa,0BAA0B,mBACvC,IAAA,YAAA,CAAa,0BAA0B,UACvC,EAAA;AACA,MAAA,YAAA,GAAe,MAAM,GAAI,CAAA,aAAA,CAAc,IAAK,CAAA,MAAA,EAAQ,aAAa,GAAG,CAAA;AACpE,MAAA,GAAA,CAAI,MAAO,CAAA,IAAA,CAAK,CAAG,EAAA,YAAA,CAAa,qBAAqB,CAAE,CAAA,CAAA;AAAA;AAGzD,IAAM,MAAA,aAAA,GAAgB,MAAM,GAAA,CAAI,qBAAsB,CAAA,gBAAA;AAAA,MACpD,MAAA;AAAA,MACA;AAAA,QACE,iBAAiB,YAAa,CAAA;AAAA;AAChC,KACF;AAEA,IAAO,OAAA,aAAA,CACJ,OAAO,CAAQ,IAAA,KAAA,IAAA,CAAK,uBAAuB,KAAS,CAAA,CAAA,CACpD,IAAI,CAAQ,IAAA,KAAA;AACX,MAAA,OAAO,IAAK,CAAA,kBAAA;AAAA,KACb,CACA,CAAA,IAAA,GACA,GAAI,CAAA,CAAA,IAAA,KAAQ,KAAK,EAAE,CAAA;AAAA,WACf,CAAG,EAAA;AACV,IAAA,GAAA,CAAI,MAAO,CAAA,IAAA;AAAA,MACT,CAAA,yCAAA,EAA4C,eAAe,CAAK,EAAA,EAAAC,uBAAA;AAAA,QAC9D;AAAA,OACD,CAAA,oEAAA;AAAA,KACH;AACA,IAAA,OAAO,EAAC;AAAA;AAEZ;AAOa,MAAA,qCAAA,GAAwC,CAAC,OAEhD,KAAA;AACJ,EAAM,MAAA,EAAE,cAAiB,GAAA,OAAA;AAEzB,EAAA,OAAOC,yCAgBJ,CAAA;AAAA,IACD,EAAI,EAAA,8BAAA;AAAA,cACJC,oCAAA;AAAA,IACA,MAAQ,EAAA;AAAA,MACN,KAAO,EAAA;AAAA,QACL,QAAA,EAAU,CAAC,SAAA,EAAW,YAAY,CAAA;AAAA,QAClC,IAAM,EAAA,QAAA;AAAA,QACN,UAAY,EAAA;AAAA,UACV,OAAS,EAAA;AAAA,YACP,IAAM,EAAA,QAAA;AAAA,YACN,KAAO,EAAA,qBAAA;AAAA,YACP,WAAa,EAAA,CAAA,sJAAA;AAAA,WAGf;AAAA;AAAA,UAEA,SAAW,EAAA;AAAA,YACT,IAAM,EAAA,QAAA;AAAA,YACN,KAAO,EAAA,WAAA;AAAA,YACP,WAAa,EAAA;AAAA,WACf;AAAA,UACA,KAAO,EAAA;AAAA,YACL,IAAM,EAAA,QAAA;AAAA,YACN,KAAO,EAAA,oBAAA;AAAA,YACP,WAAa,EAAA;AAAA,WACf;AAAA,UACA,WAAa,EAAA;AAAA,YACX,IAAM,EAAA,QAAA;AAAA,YACN,KAAO,EAAA,2BAAA;AAAA,YACP,WAAa,EAAA;AAAA,WACf;AAAA,UACA,UAAY,EAAA;AAAA,YACV,IAAM,EAAA,QAAA;AAAA,YACN,KAAO,EAAA,oBAAA;AAAA,YACP,WAAa,EAAA;AAAA,WACf;AAAA,UACA,gBAAkB,EAAA;AAAA,YAChB,IAAM,EAAA,QAAA;AAAA,YACN,KAAO,EAAA,oBAAA;AAAA,YACP,WAAa,EAAA;AAAA,WACf;AAAA,UACA,UAAY,EAAA;AAAA,YACV,IAAM,EAAA,QAAA;AAAA,YACN,KAAO,EAAA,sBAAA;AAAA,YACP,WAAa,EAAA,CAAA,oOAAA;AAAA,WAKf;AAAA,UACA,UAAY,EAAA;AAAA,YACV,IAAM,EAAA,QAAA;AAAA,YACN,KAAO,EAAA,yBAAA;AAAA,YACP,WAAa,EAAA;AAAA,WACf;AAAA,UACA,KAAO,EAAA;AAAA,YACL,KAAO,EAAA,sBAAA;AAAA,YACP,IAAM,EAAA,QAAA;AAAA,YACN,WAAa,EAAA;AAAA,WACf;AAAA,UACA,YAAc,EAAA;AAAA,YACZ,KAAO,EAAA,eAAA;AAAA,YACP,IAAM,EAAA,QAAA;AAAA,YACN,IAAM,EAAA,CAAC,QAAU,EAAA,QAAA,EAAU,UAAU,MAAM,CAAA;AAAA,YAC3C,WAAa,EAAA,CAAA;AAAA,4GAAA;AAAA,WAGf;AAAA,UACA,kBAAoB,EAAA;AAAA,YAClB,KAAO,EAAA,sBAAA;AAAA,YACP,IAAM,EAAA,SAAA;AAAA,YACN,WACE,EAAA;AAAA,WACJ;AAAA,UACA,QAAU,EAAA;AAAA,YACR,KAAO,EAAA,wBAAA;AAAA,YACP,IAAM,EAAA,QAAA;AAAA,YACN,WAAa,EAAA;AAAA,WACf;AAAA,UACA,SAAW,EAAA;AAAA,YACT,KAAO,EAAA,yBAAA;AAAA,YACP,IAAM,EAAA,OAAA;AAAA,YACN,KAAO,EAAA;AAAA,cACL,IAAM,EAAA;AAAA,aACR;AAAA,YACA,WAAa,EAAA;AAAA,WACf;AAAA,UACA,gCAAkC,EAAA;AAAA,YAChC,KAAO,EAAA,sCAAA;AAAA,YACP,IAAM,EAAA,SAAA;AAAA,YACN,WACE,EAAA;AAAA;AACJ;AACF,OACF;AAAA,MACA,MAAQ,EAAA;AAAA,QACN,IAAM,EAAA,QAAA;AAAA,QACN,UAAY,EAAA;AAAA,UACV,gBAAkB,EAAA;AAAA,YAChB,KAAO,EAAA,yCAAA;AAAA,YACP,IAAM,EAAA;AAAA,WACR;AAAA,UACA,SAAW,EAAA;AAAA,YACT,KAAO,EAAA,8BAAA;AAAA,YACP,IAAM,EAAA;AAAA,WACR;AAAA,UACA,WAAa,EAAA;AAAA,YACX,KAAO,EAAA,qBAAA;AAAA,YACP,IAAM,EAAA;AAAA,WACR;AAAA,UACA,eAAiB,EAAA;AAAA,YACf,KAAO,EAAA,sBAAA;AAAA,YACP,IAAM,EAAA,QAAA;AAAA,YACN,WAAa,EAAA;AAAA;AACf;AACF;AACF,KACF;AAAA,IACA,MAAM,QAAQ,GAAK,EAAA;AACjB,MAAM,MAAA;AAAA,QACJ,QAAA;AAAA,QACA,SAAA;AAAA,QACA,UAAA;AAAA,QACA,gBAAA;AAAA,QACA,WAAA;AAAA,QACA,OAAA;AAAA,QACA,kBAAA;AAAA,QACA,UAAA;AAAA,QACA,UAAA;AAAA,QACA,KAAA;AAAA,QACA;AAAA,UACE,GAAI,CAAA,KAAA;AAER,MAAA,MAAM,EAAE,KAAO,EAAA,IAAA,EAAM,SAAY,GAAAC,iCAAA,CAAa,SAAS,YAAY,CAAA;AACnE,MAAA,MAAM,SAAS,OAAU,GAAA,OAAA,GAAU,CAAG,EAAA,KAAK,IAAI,IAAI,CAAA,CAAA;AAEnD,MAAA,MAAM,MAAMC,uBAAgB,CAAA;AAAA,QAC1B,YAAA;AAAA,QACA,KAAA;AAAA,QACA;AAAA,OACD,CAAA;AAED,MAAA,IAAI,UAAiC,GAAA,KAAA,CAAA;AAErC,MAAA,IAAI,aAAa,KAAW,CAAA,EAAA;AAC1B,QAAI,IAAA;AACF,UAAM,MAAA,YAAA,GAAe,MAAM,GAAI,CAAA,KAAA,CAAM,IAAI,EAAE,QAAA,EAAU,UAAU,CAAA;AAC/D,UAAa,UAAA,GAAA,YAAA,CAAa,CAAC,CAAE,CAAA,EAAA;AAAA,iBACtB,CAAG,EAAA;AACV,UAAA,GAAA,CAAI,MAAO,CAAA,IAAA;AAAA,YACT,CAAA,kCAAA,EAAqC,QAAQ,CAAK,EAAA,EAAAJ,uBAAA;AAAA,cAChD;AAAA,aACD,CAAA,kDAAA;AAAA,WACH;AAAA;AACF;AAGF,MAAA,IAAI,WAAoC,GAAA,KAAA,CAAA;AACxC,MAAA,IAAI,cAAc,KAAW,CAAA,EAAA;AAC3B,QAAA,WAAA,GAAA,CACE,MAAM,OAAQ,CAAA,GAAA;AAAA,UACZ,SAAA,CAAU,GAAI,CAAA,OAAM,QAAY,KAAA;AAC9B,YAAI,IAAA;AACF,cAAA,MAAM,YAAe,GAAA,MAAM,GAAI,CAAA,KAAA,CAAM,GAAI,CAAA;AAAA,gBACvC,QAAU,EAAA;AAAA,eACX,CAAA;AACD,cAAO,OAAA,YAAA,CAAa,CAAC,CAAE,CAAA,EAAA;AAAA,qBAChB,CAAG,EAAA;AACV,cAAA,GAAA,CAAI,MAAO,CAAA,IAAA;AAAA,gBACT,CAAA,kCAAA,EAAqC,QAAQ,CAAA,EAAA,EAAK,CAAC,CAAA,+CAAA;AAAA,eACrD;AACA,cAAO,OAAA,KAAA,CAAA;AAAA;AACT,WACD;AAAA,SAEH,EAAA,MAAA,CAAO,CAAM,EAAA,KAAA,EAAA,KAAO,KAAS,CAAA,CAAA;AAAA;AAGjC,MAAI,IAAA,QAAA;AACJ,MAAA,IAAI,UAAY,EAAA;AACd,QAAW,QAAA,GAAAK,qCAAA,CAAqB,GAAI,CAAA,aAAA,EAAe,UAAU,CAAA;AAAA,iBACpD,UAAY,EAAA;AAErB,QAAW,QAAA,GAAAA,qCAAA,CAAqB,GAAI,CAAA,aAAA,EAAe,UAAU,CAAA;AAAA,OACxD,MAAA;AACL,QAAA,QAAA,GAAW,GAAI,CAAA,aAAA;AAAA;AAGjB,MAAM,MAAA,YAAA,GAAe,MAAMC,+CAAA,CAA2B,QAAU,EAAA;AAAA,QAC9D,SAAW,EAAA;AAAA,OACZ,CAAA;AAED,MAAA,IAAI,YAAe,GAAA,gBAAA;AACnB,MAAA,IAAI,CAAC,YAAc,EAAA;AACjB,QAAA,MAAM,QAAW,GAAA,MAAM,GAAI,CAAA,QAAA,CAAS,KAAK,MAAM,CAAA;AAC/C,QAAM,MAAA,aAAA,GAAgB,QAAS,CAAA,cAAA,IAAkB,QAAS,CAAA,aAAA;AAC1D,QAAA,IAAI,OAAO,aAAA,KAAkB,QAAY,IAAA,CAAC,aAAe,EAAA;AACvD,UAAA,MAAM,IAAIC,iBAAA;AAAA,YACR,iIAAiI,IAAK,CAAA,SAAA;AAAA,cACpI;AAAA,aACD,CAAA;AAAA,WACH;AAAA;AAEF,QAAe,YAAA,GAAA,aAAA;AAAA;AAGjB,MAAA,IAAI,cAAsC,EAAC;AAC3C,MAAA,IAAA,CAAK,GAAI,CAAA,KAAA,CAAM,YAAgB,IAAA,MAAA,MAAY,MAAQ,EAAA;AACjD,QAAI,IAAA;AACF,UAAA,WAAA,GAAc,MAAM,GAAA,CAAI,YAAa,CAAA,kBAAA,CAAmB,MAAQ,EAAA;AAAA,YAC9D,GAAK,EAAA,YAAA;AAAA,YACL,SAAW,EAAA,IAAA;AAAA,YACX,MAAM,UAAc,IAAA,KAAA;AAAA,WACrB,CAAA;AAAA,iBACM,CAAG,EAAA;AACV,UAAA,GAAA,CAAI,MAAO,CAAA,IAAA;AAAA,YACT,CAA4C,yCAAA,EAAA,MAAM,CAAa,UAAA,EAAA,YAAY,CAAO,IAAA,EAAAP,uBAAA;AAAA,cAChF;AAAA,aACD,CAAA;AAAA,WACH;AAAA;AACF;AAEF,MAAM,MAAA,OAAA,GACJ,IAAI,KAAM,CAAA,YAAA,KAAiB,SACvB,EAAC,GAAA,CAGG,MAAM,OAAQ,CAAA,GAAA;AAAA,QACZ,YAAA,CAAa,GAAI,CAAA,OAAM,IAAQ,KAAA;AAC7B,UAAA,MAAM,SAAS,MAAM,aAAA;AAAA,YACnB,EAAE,MAAM,UAAW,EAAA;AAAA,YACnB,EAAE,MAAQ,EAAA,MAAA,EAAQ,YAAc,EAAA;AAAA,YAChC,GAAA;AAAA,YACA,GAAI,CAAA,MAAA;AAAA,YACJ,WAAA;AAAA,YACA,IAAI,KAAM,CAAA;AAAA,WACZ;AACA,UAAO,OAAA,EAAE,MAAM,MAAO,EAAA;AAAA,SACvB;AAAA,OAEH,EAAA,MAAA,CAAO,CAAK,CAAA,KAAA,CAAA,CAAE,MAAW,KAAA,MAAM,CAIjC,CAAA,GAAA,CAAI,CAAC,EAAE,IAAM,EAAA,MAAA,EAAc,MAAA;AAAA,QAC3B,MAAA;AAAA,QACA,QAAA,EAAU,aACND,qBAAK,CAAA,KAAA,CAAM,KAAK,UAAY,EAAA,IAAA,CAAK,IAAI,CAAA,GACrC,IAAK,CAAA,IAAA;AAAA,QACT,QAAU,EAAA,QAAA;AAAA,QACV,OAAS,EAAA,IAAA,CAAK,OAAQ,CAAA,QAAA,CAAS,QAAQ,CAAA;AAAA,QACvC,kBAAkB,IAAK,CAAA;AAAA,OACvB,CAAA,CAAA;AAER,MAAI,IAAA,YAAA;AACJ,MAAA,IAAI,QAAQ,MAAQ,EAAA;AAClB,QAAe,YAAA,GAAA,IAAA;AAAA,OACV,MAAA;AACL,QAAI,IAAA;AACF,UAAA,MAAM,GAAI,CAAA,QAAA,CAAS,IAAK,CAAA,MAAA,EAAQ,UAAU,CAAA;AAC1C,UAAe,YAAA,GAAA,KAAA;AACf,UAAA,GAAA,CAAI,MAAO,CAAA,IAAA;AAAA,YACT,yBAAyB,UAAU,CAAA,sBAAA;AAAA,WACrC;AAAA,iBACO,CAAG,EAAA;AACV,UAAe,YAAA,GAAA,IAAA;AAAA;AACjB;AAEF,MAAA,IAAI,YAAc,EAAA;AAChB,QAAI,IAAA;AACF,UAAA,MAAM,IAAI,QAAS,CAAA,MAAA,CAAO,QAAQ,UAAY,EAAA,MAAA,CAAO,YAAY,CAAC,CAAA;AAAA,iBAC3D,CAAG,EAAA;AACV,UAAA,MAAM,IAAIQ,iBAAA;AAAA,YACR,CAAA,iGAAA,EAAoG,UAAU,CAAM,GAAA,EAAAP,uBAAA;AAAA,cAClH;AAAA,aACD,CAAA;AAAA,WACH;AAAA;AACF;AAEF,MAAA,MAAM,IAAI,UAAW,CAAA;AAAA,QACnB,GAAK,EAAA,CAAA,UAAA,EAAa,MAAM,CAAA,CAAA,EAAI,UAAU,CAAA,CAAA;AAAA,QACtC,IAAI,YAAY;AACd,UAAA,IAAI,QAAQ,MAAQ,EAAA;AAClB,YAAI,IAAA;AACF,cAAM,MAAA,MAAA,GAAS,MAAM,GAAA,CAAI,OAAQ,CAAA,MAAA;AAAA,gBAC/B,MAAA;AAAA,gBACA,UAAA;AAAA,gBACA,KAAA;AAAA,gBACA;AAAA,eACF;AACA,cAAA,OAAO,MAAO,CAAA,EAAA;AAAA,qBACP,CAAG,EAAA;AACV,cAAA,MAAM,IAAIO,iBAAA;AAAA,gBACR,CAAA,0BAAA,EAA6B,UAAU,CAAwF,qFAAA,EAAAP,uBAAA;AAAA,kBAC7H;AAAA,iBACD,CAAA;AAAA,eACH;AAAA;AACF;AAEF,UAAO,OAAA,IAAA;AAAA;AACT,OACD,CAAA;AAED,MAAA,MAAM,EAAE,IAAM,EAAA,QAAA,EAAa,GAAA,MAAM,IAAI,UAAW,CAAA;AAAA,QAC9C,GAAK,EAAA,CAAA,UAAA,EAAa,MAAM,CAAA,CAAA,EAAI,UAAU,CAAA,CAAA;AAAA,QACtC,IAAI,YAAY;AACd,UAAI,IAAA;AACF,YAAM,MAAA,YAAA,GAAe,MAAM,GAAA,CAAI,aAAc,CAAA,MAAA;AAAA,cAC3C,MAAA;AAAA,cACA,UAAA;AAAA,cACA,OAAO,YAAY,CAAA;AAAA,cACnB,KAAA;AAAA,cACA;AAAA,gBACE,WAAA;AAAA,gBACA,kBAAA,EAAoB,qBAChB,kBACA,GAAA,KAAA;AAAA,gBACJ,UAAA;AAAA,gBACA;AAAA;AACF,aACF;AACA,YAAO,OAAA;AAAA,cACL,MAAM,YAAa,CAAA,GAAA;AAAA,cACnB,QAAA,EAAU,YAAa,CAAA,OAAA,IAAW,YAAa,CAAA;AAAA,aACjD;AAAA,mBACO,CAAG,EAAA;AACV,YAAA,MAAM,IAAIO,iBAAA;AAAA,cACR,CAAA,+BAAA,EAAkCP,uBAAgB,CAAA,CAAC,CAAC,CAAA;AAAA,aACtD;AAAA;AACF;AACF,OACD,CAAA;AAED,MAAA,MAAM,IAAI,UAAW,CAAA;AAAA,QACnB,GAAK,EAAA,CAAA,2BAAA,EAA8B,MAAM,CAAA,CAAA,EAAI,UAAU,CAAA,CAAA;AAAA,QACvD,IAAI,YAAY;AACd,UAAI,IAAA,GAAA,CAAI,MAAM,gCAAkC,EAAA;AAC9C,YAAI,IAAA;AACF,cAAA,MAAM,6BACJ,MAAM,6BAAA,CAA8B,GAAK,EAAA,IAAA,EAAM,QAAQ,GAAG,CAAA;AAC5D,cAAI,IAAA,0BAAA,CAA2B,SAAS,CAAG,EAAA;AACzC,gBAAM,MAAA,eAAA,uBAAsB,GAAI,CAAA;AAAA,kBAC9B,GAAG,0BAAA;AAAA,kBACH,GAAI,eAAe;AAAC,iBACrB,CAAA;AAED,gBAAM,MAAA,YAAA,GAAe,MAAM,GAAA,CAAI,aAAc,CAAA,IAAA;AAAA,kBAC3C,MAAA;AAAA,kBACA,IAAA;AAAA,kBACA;AAAA,oBACE,WAAA,EAAa,KAAM,CAAA,IAAA,CAAK,eAAe;AAAA;AACzC,iBACF;AACA,gBAAO,OAAA;AAAA,kBACL,QAAA,EAAU,YAAa,CAAA,OAAA,IAAW,YAAa,CAAA;AAAA,iBACjD;AAAA;AACF,qBACO,CAAG,EAAA;AACV,cAAA,GAAA,CAAI,MAAO,CAAA,IAAA;AAAA,gBACT,CAAmD,gDAAA,EAAAA,uBAAA;AAAA,kBACjD;AAAA,iBACD,CAAA,CAAA;AAAA,eACH;AAAA;AACF;AAEF,UAAA,OAAO,EAAE,QAAS,EAAA;AAAA;AACpB,OACD,CAAA;AAED,MAAI,GAAA,CAAA,MAAA,CAAO,aAAa,MAAM,CAAA;AAC9B,MAAI,GAAA,CAAA,MAAA,CAAO,oBAAoB,YAAY,CAAA;AAC3C,MAAI,GAAA,CAAA,MAAA,CAAO,eAAe,MAAM,CAAA;AAChC,MAAI,GAAA,CAAA,MAAA,CAAO,mBAAmB,QAAQ,CAAA;AAAA;AACxC,GACD,CAAA;AACH;;;;"}