import * as _backstage_backend_plugin_api from '@backstage/backend-plugin-api';
import { AuthService, UrlReaderService, DatabaseService, BackstageCredentials, AuditorService, LifecycleService, SchedulerService, PermissionsService, HttpAuthService, DiscoveryService } from '@backstage/backend-plugin-api';
import * as _backstage_plugin_scaffolder_node from '@backstage/plugin-scaffolder-node';
import { TemplateFilter as TemplateFilter$1, TemplateGlobal as TemplateGlobal$1, TemplateAction as TemplateAction$1, TaskStatus as TaskStatus$1, TaskCompletionState as TaskCompletionState$1, SerializedTask as SerializedTask$1, TaskEventType as TaskEventType$1, SerializedTaskEvent as SerializedTaskEvent$1, TaskBrokerDispatchResult as TaskBrokerDispatchResult$1, TaskBrokerDispatchOptions as TaskBrokerDispatchOptions$1, TaskContext as TaskContext$1, TaskBroker as TaskBroker$1, TaskSecrets as TaskSecrets$1, ActionContext as ActionContext$1, createTemplateAction as createTemplateAction$1, ExecuteShellCommandOptions, executeShellCommand as executeShellCommand$1, fetchContents as fetchContents$1 } from '@backstage/plugin-scaffolder-node';
import * as _backstage_types from '@backstage/types';
import { HumanDuration, JsonObject, JsonValue } from '@backstage/types';
import * as _backstage_integration from '@backstage/integration';
import { ScmIntegrations } from '@backstage/integration';
import { CatalogApi } from '@backstage/catalog-client';
import { Config } from '@backstage/config';
import { Duration } from 'luxon';
import { createGithubActionsDispatchAction as createGithubActionsDispatchAction$1, createGithubDeployKeyAction as createGithubDeployKeyAction$1, createGithubEnvironmentAction as createGithubEnvironmentAction$1, createGithubIssuesLabelAction as createGithubIssuesLabelAction$1, CreateGithubPullRequestActionOptions as CreateGithubPullRequestActionOptions$1, createGithubRepoCreateAction as createGithubRepoCreateAction$1, createGithubRepoPushAction as createGithubRepoPushAction$1, createGithubWebhookAction as createGithubWebhookAction$1, createPublishGithubAction as createPublishGithubAction$1 } from '@backstage/plugin-scaffolder-backend-module-github';
import { createPublishGitlabAction as createPublishGitlabAction$1 } from '@backstage/plugin-scaffolder-backend-module-gitlab';
import { createPublishAzureAction as createPublishAzureAction$1 } from '@backstage/plugin-scaffolder-backend-module-azure';
import { createPublishBitbucketAction as createPublishBitbucketAction$1 } from '@backstage/plugin-scaffolder-backend-module-bitbucket';
import { createPublishBitbucketCloudAction as createPublishBitbucketCloudAction$1 } from '@backstage/plugin-scaffolder-backend-module-bitbucket-cloud';
import { createPublishBitbucketServerAction as createPublishBitbucketServerAction$1, createPublishBitbucketServerPullRequestAction as createPublishBitbucketServerPullRequestAction$1 } from '@backstage/plugin-scaffolder-backend-module-bitbucket-server';
import { createPublishGerritAction as createPublishGerritAction$1, createPublishGerritReviewAction as createPublishGerritReviewAction$1 } from '@backstage/plugin-scaffolder-backend-module-gerrit';
import { Knex } from 'knex';
import * as _backstage_plugin_scaffolder_common from '@backstage/plugin-scaffolder-common';
import { TaskSpec, TaskRecovery, TemplateEntityStepV1beta3, TemplateParametersV1beta3 } from '@backstage/plugin-scaffolder-common';
import { EventsService } from '@backstage/plugin-events-node';
import { WorkspaceProvider, CreatedTemplateFilter, CreatedTemplateGlobal, AutocompleteHandler } from '@backstage/plugin-scaffolder-node/alpha';
import { Logger } from 'winston';
import { PermissionEvaluator, PermissionRuleParams } from '@backstage/plugin-permission-common';
import { IdentityApi } from '@backstage/plugin-auth-node';
import { PermissionRule } from '@backstage/plugin-permission-node';
import { RESOURCE_TYPE_SCAFFOLDER_TEMPLATE, RESOURCE_TYPE_SCAFFOLDER_ACTION } from '@backstage/plugin-scaffolder-common/alpha';
import express from 'express';
import { ScaffolderEntitiesProcessor as ScaffolderEntitiesProcessor$1 } from '@backstage/plugin-catalog-backend-module-scaffolder-entity-model';

/**
 * Scaffolder plugin
 *
 * @public
 */
declare const scaffolderPlugin: _backstage_backend_plugin_api.BackendFeature;

/**
 * Registers entities from a catalog descriptor file in the workspace into the software catalog.
 * @public
 */
declare function createCatalogRegisterAction(options: {
    catalogClient: CatalogApi;
    integrations: ScmIntegrations;
    auth?: AuthService;
}): _backstage_plugin_scaffolder_node.TemplateAction<{
    catalogInfoUrl: string;
    optional?: boolean;
} | {
    repoContentsUrl: string;
    catalogInfoPath?: string;
    optional?: boolean;
}, _backstage_types.JsonObject, "v1">;

/**
 * Writes a catalog descriptor file containing the provided entity to a path in the workspace.
 * @public
 */
declare function createCatalogWriteAction(): _backstage_plugin_scaffolder_node.TemplateAction<{
    entity: Record<string, any>;
    filePath?: string | undefined;
}, any, "v1">;

/**
 * Returns entity or entities from the catalog by entity reference(s).
 *
 * @public
 */
declare function createFetchCatalogEntityAction(options: {
    catalogClient: CatalogApi;
    auth?: AuthService;
}): _backstage_plugin_scaffolder_node.TemplateAction<{
    entityRef?: string | undefined;
    entityRefs?: string[] | undefined;
    optional?: boolean | undefined;
    defaultKind?: string | undefined;
    defaultNamespace?: string | undefined;
}, {
    entity?: any;
    entities?: any[] | undefined;
}, "v2">;

/**
 * The options passed to {@link createBuiltinActions}
 * @public
 */
interface CreateBuiltInActionsOptions {
    /**
     * The {@link @backstage/backend-plugin-api#UrlReaderService} interface that will be used in the default actions.
     */
    reader: UrlReaderService;
    /**
     * The {@link @backstage/integrations#ScmIntegrations} that will be used in the default actions.
     */
    integrations: ScmIntegrations;
    /**
     * The {@link @backstage/catalog-client#CatalogApi} that will be used in the default actions.
     */
    catalogClient: CatalogApi;
    /**
     * The {@link @backstage/backend-plugin-api#AuthService} that will be used in the default actions.
     */
    auth?: AuthService;
    /**
     * The {@link @backstage/config#Config} that will be used in the default actions.
     */
    config: Config;
    /**
     * Additional custom filters that will be passed to the nunjucks template engine for use in
     * Template Manifests and also template skeleton files when using `fetch:template`.
     */
    additionalTemplateFilters?: Record<string, TemplateFilter$1>;
    additionalTemplateGlobals?: Record<string, TemplateGlobal$1>;
}
/**
 * A function to generate create a list of default actions that the scaffolder provides.
 * Is called internally in the default setup, but can be used when adding your own actions or overriding the default ones
 *
 * TODO(blam): version 2 of the scaffolder shouldn't ship with the additional modules. We should ship the basics, and let people install
 * modules for the providers they want to use.
 * @public
 * @returns A list of actions that can be used in the scaffolder
 *
 */
declare const createBuiltinActions: (options: CreateBuiltInActionsOptions) => TemplateAction$1[];

/**
 * Writes a message into the log or lists all files in the workspace
 *
 * @remarks
 *
 * This task is useful for local development and testing of both the scaffolder
 * and scaffolder templates.
 *
 * @public
 */
declare function createDebugLogAction(): _backstage_plugin_scaffolder_node.TemplateAction<any, any, "v1">;

/**
 * Waits for a certain period of time.
 *
 * @remarks
 *
 * This task is useful to give some waiting time for manual intervention.
 * Has to be used in a combination with other actions.
 *
 * @public
 */
declare function createWaitAction(options?: {
    maxWaitTime?: Duration | HumanDuration;
}): _backstage_plugin_scaffolder_node.TemplateAction<HumanDuration, _backstage_types.JsonObject, "v1">;

/**
 * Downloads content and places it in the workspace, or optionally
 * in a subdirectory specified by the 'targetPath' input option.
 * @public
 */
declare function createFetchPlainAction(options: {
    reader: UrlReaderService;
    integrations: ScmIntegrations;
}): _backstage_plugin_scaffolder_node.TemplateAction<{
    url: string;
    targetPath?: string;
    token?: string;
}, _backstage_types.JsonObject, "v1">;

/**
 * Downloads content and places it in the workspace, or optionally
 * in a subdirectory specified by the 'targetPath' input option.
 * @public
 */
declare function createFetchPlainFileAction(options: {
    reader: UrlReaderService;
    integrations: ScmIntegrations;
}): _backstage_plugin_scaffolder_node.TemplateAction<{
    url: string;
    targetPath: string;
    token?: string;
}, _backstage_types.JsonObject, "v1">;

/**
 * Downloads a skeleton, templates variables into file and directory names and content.
 * Then places the result in the workspace, or optionally in a subdirectory
 * specified by the 'targetPath' input option.
 *
 * @public
 */
declare function createFetchTemplateAction(options: {
    reader: UrlReaderService;
    integrations: ScmIntegrations;
    additionalTemplateFilters?: Record<string, TemplateFilter$1>;
    additionalTemplateGlobals?: Record<string, TemplateGlobal$1>;
}): _backstage_plugin_scaffolder_node.TemplateAction<{
    url: string;
    targetPath?: string;
    values: any;
    templateFileExtension?: string | boolean;
    /**
     * @deprecated This field is deprecated in favor of copyWithoutTemplating.
     */
    copyWithoutRender?: string[];
    copyWithoutTemplating?: string[];
    cookiecutterCompat?: boolean;
    replace?: boolean;
    trimBlocks?: boolean;
    lstripBlocks?: boolean;
    token?: string;
}, _backstage_types.JsonObject, "v1">;

/**
 * Downloads a single file and templates variables into file.
 * Then places the result in the workspace, or optionally in a subdirectory
 * specified by the 'targetPath' input option.
 * @public
 */
declare function createFetchTemplateFileAction(options: {
    reader: UrlReaderService;
    integrations: ScmIntegrations;
    additionalTemplateFilters?: Record<string, TemplateFilter$1>;
    additionalTemplateGlobals?: Record<string, TemplateGlobal$1>;
}): _backstage_plugin_scaffolder_node.TemplateAction<{
    url: string;
    targetPath: string;
    values: any;
    cookiecutterCompat?: boolean;
    replace?: boolean;
    trimBlocks?: boolean;
    lstripBlocks?: boolean;
    token?: string;
}, _backstage_types.JsonObject, "v1">;

/**
 * Creates new action that enables deletion of files and directories in the workspace.
 * @public
 */
declare const createFilesystemDeleteAction: () => _backstage_plugin_scaffolder_node.TemplateAction<{
    files: string[];
}, _backstage_types.JsonObject, "v1">;

/**
 * Creates a new action that allows renames of files and directories in the workspace.
 * @public
 */
declare const createFilesystemRenameAction: () => _backstage_plugin_scaffolder_node.TemplateAction<{
    files: Array<{
        from: string;
        to: string;
        overwrite?: boolean;
    }>;
}, _backstage_types.JsonObject, "v1">;

/**
 * Creates new action that enables reading directories in the workspace.
 * @public
 */
declare const createFilesystemReadDirAction: () => _backstage_plugin_scaffolder_node.TemplateAction<{
    recursive: boolean;
    paths: string[];
}, {
    files: {
        name: string;
        path: string;
        fullPath: string;
    }[];
    folders: {
        name: string;
        path: string;
        fullPath: string;
    }[];
}, "v1">;

/**
 * @public
 * @deprecated use import from `@backstage/plugin-scaffolder-backend-module-github` instead
 */
declare const createGithubActionsDispatchAction: typeof createGithubActionsDispatchAction$1;
/**
 * @public
 * @deprecated use import from `@backstage/plugin-scaffolder-backend-module-github` instead
 */
declare const createGithubDeployKeyAction: typeof createGithubDeployKeyAction$1;
/**
 * @public
 * @deprecated use import from `@backstage/plugin-scaffolder-backend-module-github` instead
 */
declare const createGithubEnvironmentAction: typeof createGithubEnvironmentAction$1;
/**
 * @public
 * @deprecated use import from `@backstage/plugin-scaffolder-backend-module-github` instead
 */
declare const createGithubIssuesLabelAction: typeof createGithubIssuesLabelAction$1;
/**
 * @public
 * @deprecated use import from `@backstage/plugin-scaffolder-backend-module-github` instead
 */
type CreateGithubPullRequestActionOptions = CreateGithubPullRequestActionOptions$1;
/**
 * @public
 * @deprecated use import from `@backstage/plugin-scaffolder-backend-module-github` instead
 */
declare const createGithubRepoCreateAction: typeof createGithubRepoCreateAction$1;
/**
 * @public
 * @deprecated use import from `@backstage/plugin-scaffolder-backend-module-github` instead
 */
declare const createGithubRepoPushAction: typeof createGithubRepoPushAction$1;
/**
 * @public
 * @deprecated use import from `@backstage/plugin-scaffolder-backend-module-github` instead
 */
declare const createGithubWebhookAction: typeof createGithubWebhookAction$1;
/**
 * @public
 * @deprecated use import from `@backstage/plugin-scaffolder-backend-module-github` instead
 */
declare const createPublishGithubAction: typeof createPublishGithubAction$1;
/**
 * @public
 * @deprecated use import from `@backstage/plugin-scaffolder-backend-module-github` instead
 */
declare const createPublishGithubPullRequestAction: (options: CreateGithubPullRequestActionOptions$1) => _backstage_plugin_scaffolder_node.TemplateAction<{
    title: string;
    branchName: string;
    targetBranchName?: string;
    description: string;
    repoUrl: string;
    draft?: boolean;
    targetPath?: string;
    sourcePath?: string;
    token?: string;
    reviewers?: string[];
    teamReviewers?: string[];
    commitMessage?: string;
    update?: boolean;
    forceFork?: boolean;
    gitAuthorName?: string;
    gitAuthorEmail?: string;
    forceEmptyGitAuthor?: boolean;
    createWhenEmpty?: boolean;
}, _backstage_types.JsonObject, "v1">;
/**
 * @public @deprecated use "createPublishBitbucketCloudAction" from \@backstage/plugin-scaffolder-backend-module-bitbucket-cloud or "createPublishBitbucketServerAction" from \@backstage/plugin-scaffolder-backend-module-bitbucket-server instead
 */
declare const createPublishBitbucketAction: typeof createPublishBitbucketAction$1;
/**
 * @public
 * @deprecated use import from `@backstage/plugin-scaffolder-backend-module-bitbucket-cloud` instead
 */
declare const createPublishBitbucketCloudAction: typeof createPublishBitbucketCloudAction$1;
/**
 * @public
 * @deprecated use import from `@backstage/plugin-scaffolder-backend-module-bitbucket-server` instead
 */
declare const createPublishBitbucketServerAction: typeof createPublishBitbucketServerAction$1;
/**
 * @public
 * @deprecated use import from `@backstage/plugin-scaffolder-backend-module-bitbucket-server` instead
 */
declare const createPublishBitbucketServerPullRequestAction: typeof createPublishBitbucketServerPullRequestAction$1;
/**
 * @public
 * @deprecated use import from `@backstage/plugin-scaffolder-backend-module-azure` instead
 */
declare const createPublishAzureAction: typeof createPublishAzureAction$1;
/**
 * @public
 * @deprecated use import from `@backstage/plugin-scaffolder-backend-module-gerrit` instead
 */
declare const createPublishGerritAction: typeof createPublishGerritAction$1;
/**
 * @public
 * @deprecated use import from `@backstage/plugin-scaffolder-backend-module-gerrit` instead
 */
declare const createPublishGerritReviewAction: typeof createPublishGerritReviewAction$1;
/**
 * @public
 * @deprecated use import from `@backstage/plugin-scaffolder-backend-module-gitlab` instead
 */
declare const createPublishGitlabAction: typeof createPublishGitlabAction$1;
/**
 * @public
 * @deprecated use import from `@backstage/plugin-scaffolder-backend-module-gitlab` instead
 */
declare const createPublishGitlabMergeRequestAction: (options: {
    integrations: _backstage_integration.ScmIntegrationRegistry;
}) => _backstage_plugin_scaffolder_node.TemplateAction<{
    repoUrl: string;
    title: string;
    description: string;
    branchName: string;
    targetBranchName?: string;
    sourcePath?: string;
    targetPath?: string;
    token?: string;
    commitAction?: "create" | "delete" | "update" | "skip" | "auto";
    projectid?: string;
    removeSourceBranch?: boolean;
    assignee?: string;
    reviewers?: string[];
    assignReviewersFromApprovalRules?: boolean;
}, _backstage_types.JsonObject, "v1">;

/**
 * Registry of all registered template actions.
 * @public
 */
declare class TemplateActionRegistry {
    private readonly actions;
    register(action: TemplateAction$1<any, any, any>): void;
    get(actionId: string): TemplateAction$1<any, any, any>;
    list(): TemplateAction$1<any, any, any>[];
}

/**
 * The status of each step of the Task
 *
 * @public
 * @deprecated Import from `@backstage/plugin-scaffolder-node` instead.
 */
type TaskStatus = TaskStatus$1;
/**
 * The state of a completed task.
 *
 * @public
 * @deprecated Import from `@backstage/plugin-scaffolder-node` instead.
 */
type TaskCompletionState = TaskCompletionState$1;
/**
 * SerializedTask
 *
 * @public
 * @deprecated Import from `@backstage/plugin-scaffolder-node` instead.
 */
type SerializedTask = SerializedTask$1;
/**
 * TaskEventType
 *
 * @public
 * @deprecated Import from `@backstage/plugin-scaffolder-node` instead.
 */
type TaskEventType = TaskEventType$1;
/**
 * SerializedTaskEvent
 *
 * @public
 * @deprecated Import from `@backstage/plugin-scaffolder-node` instead.
 */
type SerializedTaskEvent = SerializedTaskEvent$1;
/**
 * The result of `TaskBroker.dispatch`.
 *
 * @public
 * @deprecated Import from `@backstage/plugin-scaffolder-node` instead.
 */
type TaskBrokerDispatchResult = TaskBrokerDispatchResult$1;
/**
 * The options passed to `TaskBroker.dispatch`.
 * Currently a spec and optional secrets
 *
 * @public
 * @deprecated Import from `@backstage/plugin-scaffolder-node` instead.
 */
type TaskBrokerDispatchOptions = TaskBrokerDispatchOptions$1;
/**
 * Task
 *
 * @public
 * @deprecated Import from `@backstage/plugin-scaffolder-node` instead.
 */
type TaskContext = TaskContext$1;
/**
 * TaskBroker
 *
 * @public
 * @deprecated Import from `@backstage/plugin-scaffolder-node` instead.
 */
type TaskBroker = TaskBroker$1;
/**
 * TaskStoreEmitOptions
 *
 * @public
 */
type TaskStoreEmitOptions<TBody = JsonObject> = {
    taskId: string;
    body: TBody;
};
/**
 * TaskStoreListEventsOptions
 *
 * @public
 */
type TaskStoreListEventsOptions = {
    isTaskRecoverable?: boolean;
    taskId: string;
    after?: number | undefined;
};
/**
 * TaskStoreShutDownTaskOptions
 *
 * @public
 */
type TaskStoreShutDownTaskOptions = {
    taskId: string;
};
/**
 * The options passed to {@link TaskStore.createTask}
 * @public
 */
type TaskStoreCreateTaskOptions = {
    spec: TaskSpec;
    createdBy?: string;
    secrets?: TaskSecrets$1;
};
/**
 * The options passed to {@link TaskStore.recoverTasks}
 * @public
 */
type TaskStoreRecoverTaskOptions = {
    timeout: HumanDuration;
};
/**
 * The response from {@link TaskStore.createTask}
 * @public
 */
type TaskStoreCreateTaskResult = {
    taskId: string;
};
/**
 * TaskStore
 *
 * @public
 */
interface TaskStore {
    cancelTask?(options: TaskStoreEmitOptions): Promise<void>;
    createTask(options: TaskStoreCreateTaskOptions): Promise<TaskStoreCreateTaskResult>;
    retryTask?(options: {
        taskId: string;
    }): Promise<void>;
    recoverTasks?(options: TaskStoreRecoverTaskOptions): Promise<{
        ids: string[];
    }>;
    getTask(taskId: string): Promise<SerializedTask>;
    claimTask(): Promise<SerializedTask | undefined>;
    completeTask(options: {
        taskId: string;
        status: TaskStatus;
        eventBody: JsonObject;
    }): Promise<void>;
    heartbeatTask(taskId: string): Promise<void>;
    listStaleTasks(options: {
        timeoutS: number;
    }): Promise<{
        tasks: {
            taskId: string;
        }[];
    }>;
    list?(options: {
        filters?: {
            createdBy?: string | string[];
            status?: TaskStatus | TaskStatus[];
        };
        pagination?: {
            limit?: number;
            offset?: number;
        };
        order?: {
            order: 'asc' | 'desc';
            field: string;
        }[];
    }): Promise<{
        tasks: SerializedTask[];
        totalTasks?: number;
    }>;
    /**
     * @deprecated Make sure to pass `createdBy` and `status` in the `filters` parameter instead
     */
    list?(options: {
        createdBy?: string;
        status?: TaskStatus;
        filters?: {
            createdBy?: string | string[];
            status?: TaskStatus | TaskStatus[];
        };
        pagination?: {
            limit?: number;
            offset?: number;
        };
        order?: {
            order: 'asc' | 'desc';
            field: string;
        }[];
    }): Promise<{
        tasks: SerializedTask[];
        totalTasks?: number;
    }>;
    emitLogEvent(options: TaskStoreEmitOptions): Promise<void>;
    getTaskState?({ taskId }: {
        taskId: string;
    }): Promise<{
        state: JsonObject;
    } | undefined>;
    saveTaskState?(options: {
        taskId: string;
        state?: JsonObject;
    }): Promise<void>;
    listEvents(options: TaskStoreListEventsOptions): Promise<{
        events: SerializedTaskEvent[];
    }>;
    shutdownTask?(options: TaskStoreShutDownTaskOptions): Promise<void>;
    rehydrateWorkspace?(options: {
        taskId: string;
        targetPath: string;
    }): Promise<void>;
    cleanWorkspace?({ taskId }: {
        taskId: string;
    }): Promise<void>;
    serializeWorkspace?({ path, taskId, }: {
        path: string;
        taskId: string;
    }): Promise<void>;
}

/**
 * DatabaseTaskStore
 *
 * @public
 */
type DatabaseTaskStoreOptions = {
    database: DatabaseService | Knex;
    events?: EventsService;
};
/**
 * DatabaseTaskStore
 *
 * @public
 */
declare class DatabaseTaskStore implements TaskStore {
    private readonly db;
    private readonly events?;
    static create(options: DatabaseTaskStoreOptions): Promise<DatabaseTaskStore>;
    private isRecoverableTask;
    private parseSpec;
    private parseTaskSecrets;
    private static getClient;
    private static runMigrations;
    private constructor();
    private getState;
    list(options: {
        createdBy?: string;
        status?: TaskStatus$1;
        filters?: {
            createdBy?: string | string[];
            status?: TaskStatus$1 | TaskStatus$1[];
        };
        pagination?: {
            limit?: number;
            offset?: number;
        };
        order?: {
            order: 'asc' | 'desc';
            field: string;
        }[];
    }): Promise<{
        tasks: SerializedTask$1[];
        totalTasks?: number;
    }>;
    getTask(taskId: string): Promise<SerializedTask$1>;
    createTask(options: TaskStoreCreateTaskOptions): Promise<TaskStoreCreateTaskResult>;
    claimTask(): Promise<SerializedTask$1 | undefined>;
    heartbeatTask(taskId: string): Promise<void>;
    listStaleTasks(options: {
        timeoutS: number;
    }): Promise<{
        tasks: {
            taskId: string;
            recovery?: TaskRecovery;
        }[];
    }>;
    completeTask(options: {
        taskId: string;
        status: TaskStatus$1;
        eventBody: JsonObject;
    }): Promise<void>;
    emitLogEvent(options: TaskStoreEmitOptions<{
        message: string;
    } & JsonObject>): Promise<void>;
    getTaskState({ taskId }: {
        taskId: string;
    }): Promise<{
        state: JsonObject;
    } | undefined>;
    saveTaskState(options: {
        taskId: string;
        state?: JsonObject;
    }): Promise<void>;
    listEvents(options: TaskStoreListEventsOptions): Promise<{
        events: SerializedTaskEvent$1[];
    }>;
    shutdownTask(options: TaskStoreShutDownTaskOptions): Promise<void>;
    rehydrateWorkspace(options: {
        taskId: string;
        targetPath: string;
    }): Promise<void>;
    cleanWorkspace({ taskId }: {
        taskId: string;
    }): Promise<void>;
    serializeWorkspace(options: {
        path: string;
        taskId: string;
    }): Promise<void>;
    cancelTask(options: TaskStoreEmitOptions<{
        message: string;
    } & JsonObject>): Promise<void>;
    retryTask?(options: {
        taskId: string;
    }): Promise<void>;
    recoverTasks(options: TaskStoreRecoverTaskOptions): Promise<{
        ids: string[];
    }>;
}

/**
 * TaskManager
 *
 * @public
 */
declare class TaskManager implements TaskContext$1 {
    private readonly task;
    private readonly storage;
    private readonly signal;
    private readonly logger;
    private readonly workspaceService;
    private readonly auth?;
    private isDone;
    private heartbeatTimeoutId?;
    static create(task: CurrentClaimedTask, storage: TaskStore, abortSignal: AbortSignal, logger: Logger, auth?: AuthService, config?: Config, additionalWorkspaceProviders?: Record<string, WorkspaceProvider>): TaskManager;
    private constructor();
    get spec(): _backstage_plugin_scaffolder_common.TaskSpecV1beta3;
    get cancelSignal(): AbortSignal;
    get secrets(): TaskSecrets$1 | undefined;
    get createdBy(): string | undefined;
    getWorkspaceName(): Promise<string>;
    rehydrateWorkspace?(options: {
        taskId: string;
        targetPath: string;
    }): Promise<void>;
    get done(): boolean;
    emitLog(message: string, logMetadata?: JsonObject): Promise<void>;
    getTaskState?(): Promise<{
        state?: JsonObject;
    } | undefined>;
    updateCheckpoint?(options: {
        key: string;
        status: 'success';
        value: JsonValue;
    } | {
        key: string;
        status: 'failed';
        reason: string;
    }): Promise<void>;
    serializeWorkspace?(options: {
        path: string;
    }): Promise<void>;
    cleanWorkspace?(): Promise<void>;
    complete(result: TaskCompletionState$1, metadata?: JsonObject): Promise<void>;
    private startTimeout;
    getInitiatorCredentials(): Promise<BackstageCredentials>;
}
/**
 * Stores the state of the current claimed task passed to the TaskContext
 *
 * @public
 */
interface CurrentClaimedTask {
    /**
     * The TaskSpec of the current claimed task.
     */
    spec: TaskSpec;
    /**
     * The uuid of the current claimed task.
     */
    taskId: string;
    /**
     * The secrets that are stored with the task.
     */
    secrets?: TaskSecrets$1;
    /**
     * The state of checkpoints of the task.
     */
    state?: JsonObject;
    /**
     * The creator of the task.
     */
    createdBy?: string;
    /**
     * The workspace of the task.
     */
    workspace?: Promise<Buffer>;
}

/**
 * CreateWorkerOptions
 *
 * @public
 */
type CreateWorkerOptions = {
    taskBroker: TaskBroker$1;
    actionRegistry: TemplateActionRegistry;
    integrations: ScmIntegrations;
    workingDirectory: string;
    logger: Logger;
    auditor?: AuditorService;
    additionalTemplateFilters?: Record<string, TemplateFilter$1>;
    /**
     * The number of tasks that can be executed at the same time by the worker
     * @defaultValue 10
     * @example
     * ```
     * {
     *   concurrentTasksLimit: 1,
     *   // OR
     *   concurrentTasksLimit: Infinity
     * }
     * ```
     */
    concurrentTasksLimit?: number;
    additionalTemplateGlobals?: Record<string, TemplateGlobal$1>;
    permissions?: PermissionEvaluator;
    gracefulShutdown?: boolean;
};
/**
 * TaskWorker
 *
 * @public
 */
declare class TaskWorker {
    private readonly options;
    private taskQueue;
    private logger;
    private auditor;
    private stopWorkers;
    private constructor();
    static create(options: CreateWorkerOptions): Promise<TaskWorker>;
    recoverTasks(): Promise<void>;
    start(): void;
    stop(): Promise<void>;
    protected onReadyToClaimTask(): Promise<void>;
    runOneTask(task: TaskContext$1): Promise<void>;
}

/**
 *
 * @public
 */
type TemplatePermissionRuleInput<TParams extends PermissionRuleParams = PermissionRuleParams> = PermissionRule<TemplateEntityStepV1beta3 | TemplateParametersV1beta3, {}, typeof RESOURCE_TYPE_SCAFFOLDER_TEMPLATE, TParams>;
/**
 *
 * @public
 */
type ActionPermissionRuleInput<TParams extends PermissionRuleParams = PermissionRuleParams> = PermissionRule<TemplateEntityStepV1beta3 | TemplateParametersV1beta3, {}, typeof RESOURCE_TYPE_SCAFFOLDER_ACTION, TParams>;
/**
 * RouterOptions
 *
 * @public
 * @deprecated Please migrate to the new backend system as this will be removed in the future.
 */
interface RouterOptions {
    logger: Logger;
    config: Config;
    reader: UrlReaderService;
    lifecycle?: LifecycleService;
    database: DatabaseService;
    catalogClient: CatalogApi;
    scheduler?: SchedulerService;
    actions?: TemplateAction$1<any, any, any>[];
    /**
     * @deprecated taskWorkers is deprecated in favor of concurrentTasksLimit option with a single TaskWorker
     * @defaultValue 1
     */
    taskWorkers?: number;
    /**
     * Sets the number of concurrent tasks that can be run at any given time on the TaskWorker
     * @defaultValue 10
     */
    concurrentTasksLimit?: number;
    taskBroker?: TaskBroker$1;
    additionalTemplateFilters?: Record<string, TemplateFilter$1> | CreatedTemplateFilter[];
    additionalTemplateGlobals?: Record<string, TemplateGlobal$1> | CreatedTemplateGlobal[];
    additionalWorkspaceProviders?: Record<string, WorkspaceProvider>;
    permissions?: PermissionsService;
    permissionRules?: Array<TemplatePermissionRuleInput | ActionPermissionRuleInput>;
    auth?: AuthService;
    httpAuth?: HttpAuthService;
    identity?: IdentityApi;
    discovery?: DiscoveryService;
    events?: EventsService;
    auditor?: AuditorService;
    autocompleteHandlers?: Record<string, AutocompleteHandler>;
}
/**
 * A method to create a router for the scaffolder backend plugin.
 * @public
 * @deprecated Please migrate to the new backend system as this will be removed in the future.
 */
declare function createRouter(options: RouterOptions): Promise<express.Router>;

/**
 * @public
 * @deprecated Import from `@backstage/plugin-scaffolder-node` instead.
 */
type TemplateFilter = TemplateFilter$1;
/**
 * @public
 * @deprecated Import from `@backstage/plugin-scaffolder-node` instead.
 */
type TemplateGlobal = TemplateGlobal$1;

/**
 * @public
 * @deprecated Import from {@link @backstage/plugin-scaffolder-node#ActionContext} instead
 */
type ActionContext<TInput extends JsonObject> = ActionContext$1<TInput>;
/**
 * @public
 * @deprecated Use `createTemplateAction` from `@backstage/plugin-scaffolder-node` instead
 */
declare const createTemplateAction: typeof createTemplateAction$1;
/**
 * @public
 * @deprecated Use `TaskSecrets` from `@backstage/plugin-scaffolder-node` instead
 */
type TaskSecrets = TaskSecrets$1;
/**
 * @public
 * @deprecated Use `TemplateAction` from `@backstage/plugin-scaffolder-node` instead
 */
type TemplateAction<TInput extends JsonObject> = TemplateAction$1<TInput>;
/**
 * Options for {@link executeShellCommand}.
 *
 * @public
 * @deprecated Use `ExecuteShellCommandOptions` from `@backstage/plugin-scaffolder-node` instead
 */
type RunCommandOptions = ExecuteShellCommandOptions;
/**
 * Run a command in a sub-process, normally a shell command.
 *
 * @public
 * @deprecated Use `executeShellCommand` from `@backstage/plugin-scaffolder-node` instead
 */
declare const executeShellCommand: typeof executeShellCommand$1;
/**
 * A helper function that reads the contents of a directory from the given URL.
 * Can be used in your own actions, and also used behind fetch:template and fetch:plain
 *
 * @public
 * @deprecated Use `fetchContents` from `@backstage/plugin-scaffolder-node` instead
 */
declare const fetchContents: typeof fetchContents$1;
/**
 * Adds support for scaffolder specific entity kinds to the catalog.
 *
 * @public
 * @deprecated Import from `@backstage/plugin-catalog-backend-module-scaffolder-entity-model` instead
 */
declare const ScaffolderEntitiesProcessor: typeof ScaffolderEntitiesProcessor$1;

export { type ActionContext, type ActionPermissionRuleInput, type CreateBuiltInActionsOptions, type CreateGithubPullRequestActionOptions, type CreateWorkerOptions, type CurrentClaimedTask, DatabaseTaskStore, type DatabaseTaskStoreOptions, type RouterOptions, type RunCommandOptions, ScaffolderEntitiesProcessor, type SerializedTask, type SerializedTaskEvent, type TaskBroker, type TaskBrokerDispatchOptions, type TaskBrokerDispatchResult, type TaskCompletionState, type TaskContext, type TaskEventType, TaskManager, type TaskSecrets, type TaskStatus, type TaskStore, type TaskStoreCreateTaskOptions, type TaskStoreCreateTaskResult, type TaskStoreEmitOptions, type TaskStoreListEventsOptions, type TaskStoreRecoverTaskOptions, type TaskStoreShutDownTaskOptions, TaskWorker, type TemplateAction, TemplateActionRegistry, type TemplateFilter, type TemplateGlobal, type TemplatePermissionRuleInput, createBuiltinActions, createCatalogRegisterAction, createCatalogWriteAction, createDebugLogAction, createFetchCatalogEntityAction, createFetchPlainAction, createFetchPlainFileAction, createFetchTemplateAction, createFetchTemplateFileAction, createFilesystemDeleteAction, createFilesystemReadDirAction, createFilesystemRenameAction, createGithubActionsDispatchAction, createGithubDeployKeyAction, createGithubEnvironmentAction, createGithubIssuesLabelAction, createGithubRepoCreateAction, createGithubRepoPushAction, createGithubWebhookAction, createPublishAzureAction, createPublishBitbucketAction, createPublishBitbucketCloudAction, createPublishBitbucketServerAction, createPublishBitbucketServerPullRequestAction, createPublishGerritAction, createPublishGerritReviewAction, createPublishGithubAction, createPublishGithubPullRequestAction, createPublishGitlabAction, createPublishGitlabMergeRequestAction, createRouter, createTemplateAction, createWaitAction, scaffolderPlugin as default, executeShellCommand, fetchContents };
