{"version":3,"file":"templating.cjs.js","sources":["../../src/util/templating.ts"],"sourcesContent":["/*\n * Copyright 2025 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport {\n  TemplateFilter,\n  TemplateGlobal,\n} from '@backstage/plugin-scaffolder-node';\nimport {\n  CreatedTemplateFilter,\n  CreatedTemplateGlobal,\n  CreatedTemplateGlobalFunction,\n  CreatedTemplateGlobalValue,\n  TemplateGlobalFunctionSchema,\n} from '@backstage/plugin-scaffolder-node/alpha';\nimport { JsonValue } from '@backstage/types';\nimport { Schema } from 'jsonschema';\nimport { ZodType, z } from 'zod';\nimport zodToJsonSchema from 'zod-to-json-schema';\n\n/**\n * Converts template filters to a record of filter functions\n */\nexport function convertFiltersToRecord(\n  filters?: Record<string, TemplateFilter> | CreatedTemplateFilter<any, any>[],\n): Record<string, TemplateFilter> {\n  if (!filters) {\n    return {};\n  }\n\n  if (Array.isArray(filters)) {\n    const result: Record<string, TemplateFilter> = {};\n    for (const filter of filters) {\n      result[filter.id] = filter.filter as TemplateFilter;\n    }\n    return result;\n  }\n\n  return filters;\n}\n\ntype ExportFunctionSchema = {\n  arguments?: Schema[];\n  output?: Schema;\n};\n\ntype ExportFilterSchema = {\n  input?: Schema;\n} & ExportFunctionSchema;\n\n/**\n * Converts a Zod function schema to JSON schema\n */\nfunction convertZodFunctionToJsonSchema(\n  t: ReturnType<TemplateGlobalFunctionSchema<any, any>>,\n): ExportFunctionSchema {\n  const args = (t.parameters().items as ZodType[]).map(\n    zt => zodToJsonSchema(zt) as Schema,\n  );\n\n  let output: Schema | undefined = undefined;\n  const returnType = t.returnType();\n  if (!returnType._unknown) {\n    output = zodToJsonSchema(returnType) as Schema;\n  }\n\n  const result: ExportFunctionSchema = {};\n  if (args.length > 0) {\n    result.arguments = args;\n  }\n  if (output) {\n    result.output = output;\n  }\n\n  return result;\n}\n\n/**\n * Converts a function schema to a filter schema\n */\nfunction convertToFilterSchema(\n  fnSchema: ExportFunctionSchema,\n): ExportFilterSchema {\n  if (fnSchema.arguments?.length) {\n    const [input, ...rest] = fnSchema.arguments;\n    const result: ExportFilterSchema = { input };\n\n    if (rest.length > 0) {\n      result.arguments = rest;\n    }\n\n    if (fnSchema.output) {\n      result.output = fnSchema.output;\n    }\n\n    return result;\n  }\n  return fnSchema;\n}\n\ntype ExportFilter = Pick<\n  CreatedTemplateFilter<any, any>,\n  'description' | 'examples'\n> & {\n  schema?: ExportFilterSchema;\n};\n\n/**\n * Extracts metadata from template filters\n */\nexport function extractFilterMetadata(\n  filters?: Record<string, TemplateFilter> | CreatedTemplateFilter<any, any>[],\n): Record<string, ExportFilter> {\n  if (!filters) {\n    return {};\n  }\n\n  if (Array.isArray(filters)) {\n    const result: Record<string, ExportFilter> = {};\n\n    for (const filter of filters) {\n      const metadata: ExportFilter = {};\n\n      if (filter.description) {\n        metadata.description = filter.description;\n      }\n\n      if (filter.examples) {\n        metadata.examples = filter.examples;\n      }\n\n      if (filter.schema) {\n        metadata.schema = convertToFilterSchema(\n          convertZodFunctionToJsonSchema(filter.schema(z)),\n        );\n      }\n\n      result[filter.id] = metadata;\n    }\n\n    return result;\n  }\n\n  // For non-array filters, return empty metadata\n  const result: Record<string, ExportFilter> = {};\n  for (const key in filters) {\n    if (filters.hasOwnProperty(key)) {\n      result[key] = {};\n    }\n  }\n  return result;\n}\n\n/**\n * Checks if a global is a function\n */\nfunction isGlobalFunction(\n  global: CreatedTemplateGlobal,\n): global is CreatedTemplateGlobalFunction<\n  TemplateGlobalFunctionSchema<any, any> | undefined,\n  any\n> {\n  return 'fn' in global;\n}\n\n/**\n * Extracts metadata from template global functions\n */\nexport function extractGlobalFunctionMetadata(\n  globals?: Record<string, TemplateGlobal> | CreatedTemplateGlobal[],\n): Record<\n  string,\n  Pick<CreatedTemplateGlobalFunction<any, any>, 'description' | 'examples'> & {\n    schema?: ExportFunctionSchema;\n  }\n> {\n  if (!globals) {\n    return {};\n  }\n\n  if (Array.isArray(globals)) {\n    const result: Record<string, any> = {};\n\n    for (const global of globals) {\n      if (isGlobalFunction(global)) {\n        const metadata: any = {\n          description: global.description,\n          examples: global.examples,\n        };\n\n        if (global.schema) {\n          metadata.schema = convertZodFunctionToJsonSchema(global.schema(z));\n        }\n\n        result[global.id] = metadata;\n      }\n    }\n\n    return result;\n  }\n\n  // For non-array globals, extract function metadata\n  const result: Record<string, any> = {};\n  for (const key in globals) {\n    if (typeof globals[key] === 'function') {\n      result[key] = {};\n    }\n  }\n  return result;\n}\n\n/**\n * Extracts metadata from template global values\n */\nexport function extractGlobalValueMetadata(\n  globals?: Record<string, TemplateGlobal> | CreatedTemplateGlobal[],\n): Record<string, Omit<CreatedTemplateGlobalValue, 'id'>> {\n  if (!globals) {\n    return {};\n  }\n\n  if (Array.isArray(globals)) {\n    const result: Record<string, Omit<CreatedTemplateGlobalValue, 'id'>> = {};\n\n    for (const global of globals) {\n      if (!isGlobalFunction(global)) {\n        result[global.id] = {\n          value: (global as CreatedTemplateGlobalValue).value,\n          description: global.description,\n        };\n      }\n    }\n\n    return result;\n  }\n\n  // For non-array globals, extract value metadata\n  const result: Record<string, Omit<CreatedTemplateGlobalValue, 'id'>> = {};\n  for (const key in globals) {\n    if (typeof globals[key] !== 'function') {\n      result[key] = { value: globals[key] as JsonValue };\n    }\n  }\n  return result;\n}\n\n/**\n * Converts template globals to a record of global values and functions\n */\nexport function convertGlobalsToRecord(\n  globals?: Record<string, TemplateGlobal> | CreatedTemplateGlobal[],\n): Record<string, TemplateGlobal> {\n  if (!globals) {\n    return {};\n  }\n\n  if (!Array.isArray(globals)) {\n    return globals;\n  }\n\n  const result: Record<string, TemplateGlobal> = {};\n  for (const global of globals) {\n    result[global.id] = isGlobalFunction(global)\n      ? (global.fn as TemplateGlobal)\n      : (global as CreatedTemplateGlobalValue).value;\n  }\n  return result;\n}\n"],"names":[],"mappings":";;;;;AAkCO,SAAS,uBACd,OACgC,EAAA;AAChC,EAAA,IAAI,CAAC,OAAS,EAAA;AACZ,IAAA,OAAO,EAAC;AAAA;AAGV,EAAI,IAAA,KAAA,CAAM,OAAQ,CAAA,OAAO,CAAG,EAAA;AAC1B,IAAA,MAAM,SAAyC,EAAC;AAChD,IAAA,KAAA,MAAW,UAAU,OAAS,EAAA;AAC5B,MAAO,MAAA,CAAA,MAAA,CAAO,EAAE,CAAA,GAAI,MAAO,CAAA,MAAA;AAAA;AAE7B,IAAO,OAAA,MAAA;AAAA;AAGT,EAAO,OAAA,OAAA;AACT;AAqHA,SAAS,iBACP,MAIA,EAAA;AACA,EAAA,OAAO,IAAQ,IAAA,MAAA;AACjB;AAsFO,SAAS,uBACd,OACgC,EAAA;AAChC,EAAA,IAAI,CAAC,OAAS,EAAA;AACZ,IAAA,OAAO,EAAC;AAAA;AAGV,EAAA,IAAI,CAAC,KAAA,CAAM,OAAQ,CAAA,OAAO,CAAG,EAAA;AAC3B,IAAO,OAAA,OAAA;AAAA;AAGT,EAAA,MAAM,SAAyC,EAAC;AAChD,EAAA,KAAA,MAAW,UAAU,OAAS,EAAA;AAC5B,IAAO,MAAA,CAAA,MAAA,CAAO,EAAE,CAAI,GAAA,gBAAA,CAAiB,MAAM,CACtC,GAAA,MAAA,CAAO,KACP,MAAsC,CAAA,KAAA;AAAA;AAE7C,EAAO,OAAA,MAAA;AACT;;;;;"}