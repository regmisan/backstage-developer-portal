import React from 'react';
import LibraryBooks from '@material-ui/icons/LibraryBooks';
import { ApiBlueprint, PageBlueprint, createExtensionInput, coreExtensionData, createExtension, NavItemBlueprint, createFrontendPlugin } from '@backstage/frontend-plugin-api';
import { createApiFactory, configApiRef, discoveryApiRef, fetchApiRef } from '@backstage/core-plugin-api';
import { compatWrapper, convertLegacyRouteRef, convertLegacyRouteRefs } from '@backstage/core-compat-api';
import { EntityContentBlueprint } from '@backstage/plugin-catalog-react/alpha';
import { SearchResultListItemBlueprint } from '@backstage/plugin-search-react/alpha';
import { AddonBlueprint, attachTechDocsAddonComponentData } from '@backstage/plugin-techdocs-react/alpha';
import { TechDocsStorageClient, TechDocsClient } from './client.esm.js';
import { rootRouteRef, rootDocsRouteRef, rootCatalogDocsRouteRef } from './routes.esm.js';
import './reader/components/TechDocsReaderProvider.esm.js';
import { TechDocsReaderLayout } from './reader/components/TechDocsReaderPage/TechDocsReaderPage.esm.js';
import 'react-helmet';
import '@material-ui/core/Grid';
import '@material-ui/lab/Skeleton';
import '@material-ui/icons/Code';
import { techdocsStorageApiRef, techdocsApiRef, TechDocsAddons } from '@backstage/plugin-techdocs-react';
import '@backstage/plugin-catalog-react';
import '@backstage/catalog-model';
import '@backstage/core-components';
import 'lodash/capitalize';
import 'react-router-dom';
import './reader/components/TechDocsReaderPageContent/TechDocsReaderPageContent.esm.js';
import './reader/components/TechDocsReaderPageSubheader/TechDocsReaderPageSubheader.esm.js';

const techDocsStorageApi = ApiBlueprint.make({
  name: "storage",
  params: {
    factory: createApiFactory({
      api: techdocsStorageApiRef,
      deps: {
        configApi: configApiRef,
        discoveryApi: discoveryApiRef,
        fetchApi: fetchApiRef
      },
      factory: ({ configApi, discoveryApi, fetchApi }) => new TechDocsStorageClient({
        configApi,
        discoveryApi,
        fetchApi
      })
    })
  }
});
const techDocsClientApi = ApiBlueprint.make({
  params: {
    factory: createApiFactory({
      api: techdocsApiRef,
      deps: {
        configApi: configApiRef,
        discoveryApi: discoveryApiRef,
        fetchApi: fetchApiRef
      },
      factory: ({ configApi, discoveryApi, fetchApi }) => new TechDocsClient({
        configApi,
        discoveryApi,
        fetchApi
      })
    })
  }
});
const techDocsSearchResultListItemExtension = SearchResultListItemBlueprint.makeWithOverrides({
  config: {
    schema: {
      title: (z) => z.string().optional(),
      lineClamp: (z) => z.number().default(5),
      asLink: (z) => z.boolean().default(true),
      asListItem: (z) => z.boolean().default(true)
    }
  },
  factory(originalFactory, { config }) {
    return originalFactory({
      predicate: (result) => result.type === "techdocs",
      component: async () => {
        const { TechDocsSearchResultListItem } = await import('./search/components/TechDocsSearchResultListItem.esm.js');
        return (props) => compatWrapper(
          /* @__PURE__ */ React.createElement(TechDocsSearchResultListItem, { ...props, ...config })
        );
      }
    });
  }
});
const techDocsPage = PageBlueprint.make({
  params: {
    defaultPath: "/docs",
    routeRef: convertLegacyRouteRef(rootRouteRef),
    loader: () => import('./home/components/TechDocsIndexPage.esm.js').then(
      (m) => compatWrapper(/* @__PURE__ */ React.createElement(m.TechDocsIndexPage, null))
    )
  }
});
const techDocsReaderPage = PageBlueprint.makeWithOverrides({
  name: "reader",
  inputs: {
    addons: createExtensionInput([AddonBlueprint.dataRefs.addon])
  },
  factory(originalFactory, { inputs }) {
    const addons = inputs.addons.map((output) => {
      const options = output.get(AddonBlueprint.dataRefs.addon);
      const Addon = options.component;
      attachTechDocsAddonComponentData(Addon, options);
      return /* @__PURE__ */ React.createElement(Addon, { key: options.name });
    });
    return originalFactory({
      defaultPath: "/docs/:namespace/:kind/:name",
      routeRef: convertLegacyRouteRef(rootDocsRouteRef),
      loader: async () => await import('./Router.esm.js').then(({ TechDocsReaderRouter }) => {
        return compatWrapper(
          /* @__PURE__ */ React.createElement(TechDocsReaderRouter, null, /* @__PURE__ */ React.createElement(TechDocsReaderLayout, null), /* @__PURE__ */ React.createElement(TechDocsAddons, null, addons))
        );
      })
    });
  }
});
const techDocsEntityContent = EntityContentBlueprint.makeWithOverrides({
  inputs: {
    addons: createExtensionInput([AddonBlueprint.dataRefs.addon]),
    emptyState: createExtensionInput(
      [coreExtensionData.reactElement.optional()],
      {
        singleton: true,
        optional: true
      }
    )
  },
  factory(originalFactory, context) {
    return originalFactory(
      {
        defaultPath: "docs",
        defaultTitle: "TechDocs",
        routeRef: convertLegacyRouteRef(rootCatalogDocsRouteRef),
        loader: () => import('./Router.esm.js').then(({ EmbeddedDocsRouter }) => {
          const addons = context.inputs.addons.map((output) => {
            const options = output.get(AddonBlueprint.dataRefs.addon);
            const Addon = options.component;
            attachTechDocsAddonComponentData(Addon, options);
            return /* @__PURE__ */ React.createElement(Addon, { key: options.name });
          });
          return compatWrapper(
            /* @__PURE__ */ React.createElement(
              EmbeddedDocsRouter,
              {
                emptyState: context.inputs.emptyState?.get(
                  coreExtensionData.reactElement
                )
              },
              /* @__PURE__ */ React.createElement(TechDocsAddons, null, addons)
            )
          );
        })
      },
      context
    );
  }
});
const techDocsEntityContentEmptyState = createExtension({
  kind: "empty-state",
  name: "entity-content",
  attachTo: { id: "entity-content:techdocs", input: "emptyState" },
  output: [coreExtensionData.reactElement.optional()],
  factory: () => []
});
const techDocsNavItem = NavItemBlueprint.make({
  params: {
    icon: LibraryBooks,
    title: "Docs",
    routeRef: convertLegacyRouteRef(rootRouteRef)
  }
});
var alpha = createFrontendPlugin({
  id: "techdocs",
  extensions: [
    techDocsClientApi,
    techDocsStorageApi,
    techDocsNavItem,
    techDocsPage,
    techDocsReaderPage,
    techDocsEntityContent,
    techDocsEntityContentEmptyState,
    techDocsSearchResultListItemExtension
  ],
  routes: convertLegacyRouteRefs({
    root: rootRouteRef,
    docRoot: rootDocsRouteRef,
    entityContent: rootCatalogDocsRouteRef
  })
});

export { alpha as default, techDocsSearchResultListItemExtension };
//# sourceMappingURL=alpha.esm.js.map
