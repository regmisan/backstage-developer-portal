import React, { useEffect } from 'react';
import Helmet from 'react-helmet';
import Grid from '@material-ui/core/Grid';
import Skeleton from '@material-ui/lab/Skeleton';
import CodeIcon from '@material-ui/icons/Code';
import { useTechDocsAddons, useTechDocsReaderPage, TechDocsAddonLocations } from '@backstage/plugin-techdocs-react';
import { entityPresentationApiRef, getEntityRelations, EntityRefLink, EntityRefLinks } from '@backstage/plugin-catalog-react';
import { RELATION_OWNED_BY, stringifyEntityRef } from '@backstage/catalog-model';
import { HeaderLabel, Header } from '@backstage/core-components';
import { useApi, configApiRef, useRouteRef } from '@backstage/core-plugin-api';
import capitalize from 'lodash/capitalize';
import { rootRouteRef } from '../../../routes.esm.js';
import { useParams } from 'react-router-dom';

const skeleton = /* @__PURE__ */ React.createElement(Skeleton, { animation: "wave", variant: "text", height: 40 });
const TechDocsReaderPageHeader = (props) => {
  const { children } = props;
  const addons = useTechDocsAddons();
  const configApi = useApi(configApiRef);
  const entityPresentationApi = useApi(entityPresentationApiRef);
  const { "*": path = "" } = useParams();
  const {
    title,
    setTitle,
    subtitle,
    setSubtitle,
    entityRef,
    metadata: { value: metadata, loading: metadataLoading },
    entityMetadata: { value: entityMetadata, loading: entityMetadataLoading }
  } = useTechDocsReaderPage();
  useEffect(() => {
    if (!metadata) return;
    setTitle(metadata.site_name);
    setSubtitle(() => {
      let { site_description } = metadata;
      if (!site_description || site_description === "None") {
        site_description = "";
      }
      return site_description;
    });
  }, [metadata, setTitle, setSubtitle]);
  const appTitle = configApi.getOptional("app.title") || "Backstage";
  const { locationMetadata, spec } = entityMetadata || {};
  const lifecycle = spec?.lifecycle;
  const ownedByRelations = entityMetadata ? getEntityRelations(entityMetadata, RELATION_OWNED_BY) : [];
  const docsRootLink = useRouteRef(rootRouteRef)();
  const labels = /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(
    HeaderLabel,
    {
      label: capitalize(entityMetadata?.kind || "entity"),
      value: /* @__PURE__ */ React.createElement(
        EntityRefLink,
        {
          color: "inherit",
          entityRef,
          title: entityMetadata?.metadata.title,
          defaultKind: "Component"
        }
      )
    }
  ), ownedByRelations.length > 0 && /* @__PURE__ */ React.createElement(
    HeaderLabel,
    {
      label: "Owner",
      value: /* @__PURE__ */ React.createElement(
        EntityRefLinks,
        {
          color: "inherit",
          entityRefs: ownedByRelations,
          defaultKind: "group"
        }
      )
    }
  ), lifecycle ? /* @__PURE__ */ React.createElement(HeaderLabel, { label: "Lifecycle", value: String(lifecycle) }) : null, locationMetadata && locationMetadata.type !== "dir" && locationMetadata.type !== "file" ? /* @__PURE__ */ React.createElement(
    HeaderLabel,
    {
      label: "",
      value: /* @__PURE__ */ React.createElement(Grid, { container: true, direction: "column", alignItems: "center" }, /* @__PURE__ */ React.createElement(Grid, { style: { padding: 0 }, item: true }, /* @__PURE__ */ React.createElement(CodeIcon, { style: { marginTop: "-25px" } })), /* @__PURE__ */ React.createElement(Grid, { style: { padding: 0 }, item: true }, "Source")),
      url: locationMetadata.target
    }
  ) : null);
  const noEntMetadata = !entityMetadataLoading && entityMetadata === void 0;
  const noTdMetadata = !metadataLoading && metadata === void 0;
  if (noEntMetadata || noTdMetadata) return null;
  const stringEntityRef = stringifyEntityRef(entityRef);
  const entityDisplayName = entityPresentationApi.forEntity(stringEntityRef).snapshot.primaryTitle;
  const removeTrailingSlash = (str) => str.replace(/\/$/, "");
  const normalizeAndSpace = (str) => str.replace(/-/g, " ").split(" ").map(capitalize).join(" ");
  let techdocsTabTitleItems = [];
  if (path !== "")
    techdocsTabTitleItems = removeTrailingSlash(path).split("/").slice(0, 3).map(normalizeAndSpace);
  const tabTitleItems = [appTitle, entityDisplayName, ...techdocsTabTitleItems];
  const tabTitle = tabTitleItems.join(" | ");
  return /* @__PURE__ */ React.createElement(
    Header,
    {
      type: "Documentation",
      typeLink: docsRootLink,
      title: title || skeleton,
      subtitle: subtitle === "" ? void 0 : subtitle || skeleton
    },
    /* @__PURE__ */ React.createElement(Helmet, { titleTemplate: "%s" }, /* @__PURE__ */ React.createElement("title", null, tabTitle)),
    labels,
    children,
    addons.renderComponentsByLocation(TechDocsAddonLocations.Header)
  );
};

export { TechDocsReaderPageHeader };
//# sourceMappingURL=TechDocsReaderPageHeader.esm.js.map
